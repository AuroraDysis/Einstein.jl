var documenterSearchIndex = {"docs":
[{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"M. C. Babiuc and others. Implementation of standard testbeds for numerical relativity. Class. Quant. Grav. 25, 125012 (2008), arXiv:0709.3559 [gr-qc].\n\n\n\nJ.-P. Berrut and L. N. Trefethen. Barycentric lagrange interpolation. SIAM review 46, 501–517 (2004).\n\n\n\nB. Fornberg. Generation of finite difference formulas on arbitrarily spaced grids. Mathematics of computation 51, 699–706 (1988).\n\n\n\nB. Fornberg. Classroom Note:Calculation of Weights in Finite Difference Formulas. SIAM Review 40, 685–691 (1998), arXiv:https://doi.org/10.1137/S0036144596322507.\n\n\n\nB. Fornberg. An algorithm for calculating Hermite-based finite difference weights. IMA Journal of Numerical Analysis 41, 801–813 (2021).\n\n\n\nD. Hilditch, A. Weyhausen and B. Brügmann. Pseudospectral method for gravitational wave collapse. Phys. Rev. D 93, 063006 (2016), arXiv:1504.04732 [gr-qc].\n\n\n\nW. J. Lentz. Generating Bessel functions in Mie scattering calculations using continued fractions. Applied optics 15, 668–671 (1976).\n\n\n\nR. M. Neal. Fast exact summation using small and large superaccumulators (2015), arXiv:1505.05571 [cs.NA].\n\n\n\nW. H. Press. Numerical recipes 3rd edition: The art of scientific computing (Cambridge university press, 2007).\n\n\n\nJ. Ripley. *JLRipley314/teuk-fortran-2020: Teuk-                Fortran-2020-v1.1                * (Aug 2023).\n\n\n\nL. C. Stein, qnm: A Python package for calculating Kerr quasinormal modes, separation constants, and spherical-spheroidal mixing coefficients. J. Open Source Softw. 4, 1683 (2019), arXiv:1908.10377 [gr-qc].\n\n\n\nB. Szilagyi, L. Lindblom and M. A. Scheel. Simulations of Binary Black Hole Mergers Using Spectral Methods. Phys. Rev. D 80, 124010 (2009), arXiv:0909.3557 [gr-qc].\n\n\n\nN. M. Temme. DLMF: §3.10 Continued Fractions ‣ Areas ‣ Chapter 3 Numerical Methods, https://dlmf.nist.gov/3.10 (09 2024) (Accessed on 09/19/2024).\n\n\n\nI. J. Thompson and A. R. Barnett. Coulomb and Bessel functions of complex arguments and order. Journal of Computational Physics 64, 490–509 (1986).\n\n\n\n","category":"page"},{"location":"cheb/#Chebyshev-Suite","page":"Chebyshev Suite","title":"Chebyshev Suite","text":"","category":"section"},{"location":"cheb/","page":"Chebyshev Suite","title":"Chebyshev Suite","text":"Modules = [GRSuite.ChebSuite]","category":"page"},{"location":"cheb/","page":"Chebyshev Suite","title":"Chebyshev Suite","text":"Modules = [GRSuite.ChebSuite]","category":"page"},{"location":"cheb/#GRSuite.ChebSuite.Cheb1Coeffs2ValsOp","page":"Chebyshev Suite","title":"GRSuite.ChebSuite.Cheb1Coeffs2ValsOp","text":"cheb1_coeffs2vals(coeffs::AbstractVector{TR})\nCheb1Coeffs2ValsOp{[TR=Float64]}(n::Integer)(coeffs::AbstractVector{TR})\n\nConvert Chebyshev coefficients to values at Chebyshev points of the 1st kind.\n\nPerformance Guide\n\nFor best performance, especially in loops or repeated calls:\n\nop = Cheb1Coeffs2ValsOp{Float64}(n)\nvalues = op(coeffs)\n\nReferences\n\nchebfun/@chebtech1/coeffs2vals.m at master · chebfun/chebfun\n\n\n\n\n\n","category":"type"},{"location":"cheb/#GRSuite.ChebSuite.Cheb1InterpOp","page":"Chebyshev Suite","title":"GRSuite.ChebSuite.Cheb1InterpOp","text":"cheb1_interp(values::AbstractVector{TR}, x::TR) where {TR<:AbstractFloat}\nCheb1InterpOp{[TR=Float64]}(n::Integer)(values::AbstractVector{TR}, x::TR) where {TR<:AbstractFloat}\n\nInterpolate values at Chebyshev points of the 1st kind using barycentric interpolation.\n\nPerformance Guide\n\nFor best performance, especially in loops or repeated calls:\n\nop = Cheb1InterpOp{Float64}(n)\ny = op(v, x)\n\n\n\n\n\n","category":"type"},{"location":"cheb/#GRSuite.ChebSuite.Cheb1Vals2CoeffsOp","page":"Chebyshev Suite","title":"GRSuite.ChebSuite.Cheb1Vals2CoeffsOp","text":"cheb1_vals2coeffs(vals::AbstractVector{TR}) where {TR<:AbstractFloat}\nCheb1Vals2CoeffsOp{[TR=Float64]}(n::Integer)(vals::VT) where {TR<:AbstractFloat}\n\nConvert values at Chebyshev points of the 1st kind into Chebyshev coefficients.\n\nPerformance Guide\n\nFor best performance, especially in loops or repeated calls:\n\nop = Cheb1Vals2CoeffsOp{Float64}(n)\nvalues = op(coeffs)\n\nReferences\n\nchebfun/@chebtech1/vals2coeffs.m at master · chebfun/chebfun\n\n\n\n\n\n","category":"type"},{"location":"cheb/#GRSuite.ChebSuite.Cheb2Coeffs2ValsOp","page":"Chebyshev Suite","title":"GRSuite.ChebSuite.Cheb2Coeffs2ValsOp","text":"cheb2_coeffs2vals(coeffs::AbstractVector{TR}) where {TR<:AbstractFloat}\nop::Cheb2Coeffs2ValsOp{[TR=Float64]}(n::Integer)(coeffs::AbstractVector{TR}) where {TR<:AbstractFloat}\n\nConvert Chebyshev coefficients to values at Chebyshev points of the 2nd kind.\n\nPerformance Guide\n\nFor best performance, especially in loops or repeated calls:\n\nop = Cheb2Coeffs2ValsOp{Float64}(n)\nvalues = op(coeffs)\n\nReferences\n\nchebfun/@chebtech2/coeffs2vals.m at master · chebfun/chebfun\n\n\n\n\n\n","category":"type"},{"location":"cheb/#GRSuite.ChebSuite.Cheb2InterpOp","page":"Chebyshev Suite","title":"GRSuite.ChebSuite.Cheb2InterpOp","text":"cheb2_coeffs2vals(coeffs::AbstractVector{TR}) where {TR<:AbstractFloat}\nCheb2Coeffs2ValsOp{[TR=Float64]}(n::Integer)(coeffs::AbstractVector{TR}) where {TR<:AbstractFloat}\n\nConvert Chebyshev coefficients to values at Chebyshev points of the 2nd kind.\n\nPerformance Guide\n\nFor best performance, especially in loops or repeated calls:\n\nop = Cheb2Coeffs2ValsOp{Float64}(n)\nvalues = op(coeffs)\n\nReferences\n\nchebfun/@chebtech2/coeffs2vals.m at master · chebfun/chebfun\n\n\n\n\n\n","category":"type"},{"location":"cheb/#GRSuite.ChebSuite.Cheb2Vals2CoeffsOp","page":"Chebyshev Suite","title":"GRSuite.ChebSuite.Cheb2Vals2CoeffsOp","text":"cheb2_vals2coeffs(vals::AbstractVector{TR}) where {TR<:AbstractFloat}\nCheb2Vals2CoeffsOp{[TR=Float64]}(n::Integer)(vals::AbstractVector{TR}) where {TR<:AbstractFloat}\n\nConvert values at Chebyshev points of the 2nd kind into Chebyshev coefficients.\n\nPerformance Guide\n\nFor best performance, especially in loops or repeated calls:\n\nop = Cheb2Vals2CoeffsOp{Float64}(n)\nvalues = op(coeffs)\n\nReferences\n\nchebfun/@chebtech2/vals2coeffs.m at master · chebfun/chebfun\n\n\n\n\n\n","category":"type"},{"location":"cheb/#GRSuite.ChebSuite.ChebCumsumOp","page":"Chebyshev Suite","title":"GRSuite.ChebSuite.ChebCumsumOp","text":"cheb_cumsum(f::AbstractVector{TR}) where {TR<:AbstractFloat}\nChebCumsumOp{[TR=Float64]}(n::TI)(f::AbstractVector{TR}) where {TR<:AbstractFloat,TI<:Integer}\n\nCompute the indefinite integral of a function given its Chebyshev coefficients.\n\nArguments\n\nf: Vector of Chebyshev coefficients of the function to be integrated\n\nReferences\n\nchebfun/@chebtech/cumsum.m at master · chebfun/chebfun\n\n\n\n\n\n","category":"type"},{"location":"cheb/#GRSuite.ChebSuite.bary-Union{Tuple{TR}, Tuple{AbstractVector{TR}, AbstractVector{TR}, AbstractVector{TR}, TR}} where TR<:AbstractFloat","page":"Chebyshev Suite","title":"GRSuite.ChebSuite.bary","text":"bary(w::AbstractVector{TR}, x::AbstractVector{TR}, f::AbstractVector{TR}, x0::TR) where {\n    TR<:AbstractFloat\n}\n\nEvaluate a polynomial interpolant using the barycentric interpolation formula.\n\nArguments\n\nw: Vector of barycentric weights\nx: Vector of interpolation points (typically Chebyshev points)\nf: Vector of function values at interpolation points\nx0: Point at which to evaluate the interpolant\n\nReference\n\nchebfun/@chebtech2/bary.m at master · chebfun/chebfun\n\n\n\n\n\n","category":"method"},{"location":"cheb/#GRSuite.ChebSuite.bary_diffmat-Union{Tuple{TR}, Tuple{AbstractVector{TR}, AbstractVector{TR}, Integer, AbstractVector{TR}}} where TR<:AbstractFloat","page":"Chebyshev Suite","title":"GRSuite.ChebSuite.bary_diffmat","text":"bary_diffmat(x; w=nothing, k=1, t=nothing)\n\nCompute the barycentric differentiation matrix.\n\nReferences:\n\nchebfun/@chebcolloc/baryDiffMat.m at master · chebfun/chebfun\n\n\n\n\n\n","category":"method"},{"location":"cheb/#GRSuite.ChebSuite.cheb1_amat-Union{Tuple{T}, Tuple{Type{T}, Integer}} where T<:AbstractFloat","page":"Chebyshev Suite","title":"GRSuite.ChebSuite.cheb1_amat","text":"cheb1_amat([T=Float64], n::Integer) where {T<:AbstractFloat}\n\nConstruct the analysis matrix A that transforms function values at Chebyshev points of the 1st kind to Chebyshev coefficients.\n\nArguments\n\nT: Element type (defaults to Float64)\nn: Number of points/coefficients\n\n\n\n\n\n","category":"method"},{"location":"cheb/#GRSuite.ChebSuite.cheb1_angles-Union{Tuple{T}, Tuple{Type{T}, Integer}} where T<:AbstractFloat","page":"Chebyshev Suite","title":"GRSuite.ChebSuite.cheb1_angles","text":"cheb1_angles([T=Float64], n::Integer) where {T<:AbstractFloat}\n\nCompute angles for Chebyshev points of the 1st kind:\n\ntheta_k = frac(2k + 1)pi2n quad k = n-1ldots0\n\nArguments\n\nT: Type parameter for the angles (e.g., Float64)\nn: Number of points\n\n\n\n\n\n","category":"method"},{"location":"cheb/#GRSuite.ChebSuite.cheb1_barywts-Union{Tuple{T}, Tuple{Type{T}, Integer}} where T<:AbstractFloat","page":"Chebyshev Suite","title":"GRSuite.ChebSuite.cheb1_barywts","text":"cheb1_barywts([T=Float64], n::Integer) where {T<:AbstractFloat}\n\nCompute the barycentric weights for Chebyshev points of the 1st kind.\n\nArguments\n\nT: Type parameter for the weights (e.g., Float64)\nn: Number of points\n\nReferences\n\nBerrut and Trefethen [BT04]\nchebfun/@chebtech1/barywts.m at master · chebfun/chebfun\n\nSee also: bary, cheb1_pts\n\n\n\n\n\n","category":"method"},{"location":"cheb/#GRSuite.ChebSuite.cheb1_cumsummat-Union{Tuple{TR}, Tuple{Type{TR}, Integer}} where TR<:AbstractFloat","page":"Chebyshev Suite","title":"GRSuite.ChebSuite.cheb1_cumsummat","text":"cheb1_cumsummat([TR=Float64], n::Integer) where {TR<:AbstractFloat}\ncheb1_cumsummat([TR=Float64], n::Integer, x_min::TR, x_max::TR) where {TR<:AbstractFloat}\n\nCompute Chebyshev integration matrix that maps function values at n Chebyshev points of the 1st kind to values of the integral of the interpolating polynomial at those points, with the convention that the first value is zero.\n\nReferences\n\nchebfun/@chebcolloc1/chebcolloc1.m at master · chebfun/chebfun\n\n\n\n\n\n","category":"method"},{"location":"cheb/#GRSuite.ChebSuite.cheb1_diffmat-Union{Tuple{TR}, Tuple{Type{TR}, Integer}, Tuple{Type{TR}, Integer, Integer}} where TR<:AbstractFloat","page":"Chebyshev Suite","title":"GRSuite.ChebSuite.cheb1_diffmat","text":"cheb1_diffmat([TR=Float64], n::Integer, k::Integer=1) where {TR<:AbstractFloat}\n\nConstruct a Chebyshev differentiation that maps function values at n Chebyshev points of the 1st kind  to values of the k-th derivative of the interpolating polynomial at those points.\n\nArguments\n\nTR: Element type (defaults to Float64)\nn::Integer: Number of Chebyshev points\nk::Integer=1: Order of the derivative (default: 1)\n\nReferences\n\nchebfun/@chebcolloc1/chebcolloc1.m at master · chebfun/chebfun\n\n\n\n\n\n","category":"method"},{"location":"cheb/#GRSuite.ChebSuite.cheb1_pts-Union{Tuple{T}, Tuple{Type{T}, Integer}} where T<:AbstractFloat","page":"Chebyshev Suite","title":"GRSuite.ChebSuite.cheb1_pts","text":"cheb1_pts([T=Float64], n::Integer) where {T<:AbstractFloat}\ncheb1_pts([T=Float64], n::Integer, x_min::T, x_max::T) where {T<:AbstractFloat}\n\nGenerate Chebyshev points of the 2nd kind.\n\nFor the standard interval [-1,1]:\n\nx_k = -cosleft(frac(2k + 1)pi2nright) quad k = 01ldotsn-1\n\nFor mapped interval [xmin,xmax]:\n\nx_mathrmmapped = fracx_mathrmmax + x_mathrmmin2 + fracx_mathrmmin - x_mathrmmax2x_k\n\nArguments\n\nT: Type parameter for the grid points (e.g., Float64)\nn: Number of points\nx_min: (Optional) Lower bound of the mapped interval\nx_max: (Optional) Upper bound of the mapped interval\n\nReferences\n\nchebfun/@chebtech1/chebpts.m at master · chebfun/chebfun\n\n\n\n\n\n","category":"method"},{"location":"cheb/#GRSuite.ChebSuite.cheb1_quadwts-Union{Tuple{TR}, Tuple{Type{TR}, Integer}} where TR<:AbstractFloat","page":"Chebyshev Suite","title":"GRSuite.ChebSuite.cheb1_quadwts","text":"cheb1_quadwts([TR=Float64], n::Integer) where {TR<:AbstractFloat}\n\nCompute quadrature weights for Chebyshev points of the 1st kind.\n\nArguments\n\nTR: Type parameter for the weights (e.g., Float64)\nn: Number of points\n\nReferences\n\nchebfun/@chebtech1/quadwts.m at master · chebfun/chebfun\n\n\n\n\n\n","category":"method"},{"location":"cheb/#GRSuite.ChebSuite.cheb1_smat-Union{Tuple{T}, Tuple{Type{T}, Integer}} where T<:AbstractFloat","page":"Chebyshev Suite","title":"GRSuite.ChebSuite.cheb1_smat","text":"cheb1_smat([T=Float64], n::Integer)\n\nConstruct the synthesis matrix S that transforms Chebyshev coefficients to function values at Chebyshev points of the 1st kind.\n\nArguments\n\nT: Element type (defaults to Float64)\nn: Number of points/coefficients\n\n\n\n\n\n","category":"method"},{"location":"cheb/#GRSuite.ChebSuite.cheb2_amat-Union{Tuple{T}, Tuple{Type{T}, Integer}} where T<:AbstractFloat","page":"Chebyshev Suite","title":"GRSuite.ChebSuite.cheb2_amat","text":"cheb2_amat([T=Float64], n::Integer) where {T<:AbstractFloat}\n\nConstruct the analysis matrix A that transforms function values at Chebyshev points of the 2nd kind to Chebyshev coefficients.\n\nArguments\n\nT: Element type (defaults to Float64)\nn: Number of points/coefficients\n\n\n\n\n\n","category":"method"},{"location":"cheb/#GRSuite.ChebSuite.cheb2_angles-Union{Tuple{T}, Tuple{Type{T}, Integer}} where T<:AbstractFloat","page":"Chebyshev Suite","title":"GRSuite.ChebSuite.cheb2_angles","text":"cheb2_angles([T=Float64], n::Integer) where {T<:AbstractFloat}\n\nCompute angles for Chebyshev points of the 2nd kind:\n\ntheta_k = frackpin-1 quad k = n-1ldots0\n\nArguments\n\nT: Type parameter for the angles (e.g., Float64)\nn: Number of points\n\n\n\n\n\n","category":"method"},{"location":"cheb/#GRSuite.ChebSuite.cheb2_barywts-Union{Tuple{T}, Tuple{Type{T}, Integer}} where T<:AbstractFloat","page":"Chebyshev Suite","title":"GRSuite.ChebSuite.cheb2_barywts","text":"cheb2_barywts([T=Float64], n::Integer) where {T<:AbstractFloat}\n\nCompute the barycentric weights for Chebyshev points of the 2nd kind.\n\nArguments\n\nT: Type parameter for the weights (e.g., Float64)\nn: Number of points\n\nReferences\n\nchebfun/@chebtech2/barywts.m at master · chebfun/chebfun\n\nSee also: bary, cheb2_pts\n\n\n\n\n\n","category":"method"},{"location":"cheb/#GRSuite.ChebSuite.cheb2_cumsummat-Union{Tuple{T}, Tuple{Type{T}, Integer}} where T<:AbstractFloat","page":"Chebyshev Suite","title":"GRSuite.ChebSuite.cheb2_cumsummat","text":"cheb2_cumsummat([T=Float64], n::Integer) where {T<:AbstractFloat}\ncheb2_cumsummat([T=Float64], n::Integer, x_min::T, x_max::T) where {T<:AbstractFloat}\n\nCompute Chebyshev integration matrix that maps function values at n Chebyshev points of the 2st kind to values of the integral of the interpolating polynomial at those points, with the convention that the first value is zero.\n\nReferences\n\nchebfun/@chebcolloc2/chebcolloc2.m at master · chebfun/chebfun\n\n\n\n\n\n","category":"method"},{"location":"cheb/#GRSuite.ChebSuite.cheb2_diffmat-Union{Tuple{TR}, Tuple{Type{TR}, Integer}, Tuple{Type{TR}, Integer, Integer}} where TR<:AbstractFloat","page":"Chebyshev Suite","title":"GRSuite.ChebSuite.cheb2_diffmat","text":"cheb2_diffmat([TR=Float64], n::Integer, k::Integer=1) where {TR<:AbstractFloat}\n\nConstruct a Chebyshev differentiation that maps function values at n Chebyshev points of the 2nd kind  to values of the k-th derivative of the interpolating polynomial at those points.\n\nArguments\n\nTR: Element type (defaults to Float64)\nn::Integer: Number of Chebyshev points\nk::Integer=1: Order of the derivative (default: 1)\n\nReferences\n\nchebfun/@chebcolloc2/chebcolloc2.m at master · chebfun/chebfun\n\n\n\n\n\n","category":"method"},{"location":"cheb/#GRSuite.ChebSuite.cheb2_pts-Union{Tuple{T}, Tuple{Type{T}, Integer}} where T<:AbstractFloat","page":"Chebyshev Suite","title":"GRSuite.ChebSuite.cheb2_pts","text":"cheb2_pts([T=Float64], n::Integer) where {T<:AbstractFloat}\ncheb2_pts([T=Float64], n::Integer, x_min::T, x_max::T) where {T<:AbstractFloat}\n\nGenerate Chebyshev points of the 1st kind.\n\nFor the standard interval [-1,1]:\n\nx_k = -cosleft(frackpin-1right) quad k = 01ldotsn-1\n\nFor mapped interval [xmin,xmax]:\n\nx_mathrmmapped = fracx_mathrmmax + x_mathrmmin2 + fracx_mathrmmin - x_mathrmmax2x_k\n\nArguments\n\nT: Type parameter for the grid points (e.g., Float64)\nn: Number of points\nx_min: (Optional) Lower bound of the mapped interval\nx_max: (Optional) Upper bound of the mapped interval\n\nReferences\n\nchebfun/@chebtech2/chebpts.m at master · chebfun/chebfun\n\n\n\n\n\n","category":"method"},{"location":"cheb/#GRSuite.ChebSuite.cheb2_quadwts-Union{Tuple{TR}, Tuple{Type{TR}, Integer}} where TR<:AbstractFloat","page":"Chebyshev Suite","title":"GRSuite.ChebSuite.cheb2_quadwts","text":"cheb2_quadwts([TR=Float64], n::Integer) where {TR<:AbstractFloat}\n\nCompute quadrature weights for Chebyshev points of the 2nd kind.\n\nArguments\n\nTR: Type parameter for the weights (e.g., Float64)\nn: Number of points\n\nReferences\n\nchebfun/@chebtech2/quadwts.m at master · chebfun/chebfun\n\n\n\n\n\n","category":"method"},{"location":"cheb/#GRSuite.ChebSuite.cheb2_smat-Union{Tuple{T}, Tuple{Type{T}, Integer}} where T<:AbstractFloat","page":"Chebyshev Suite","title":"GRSuite.ChebSuite.cheb2_smat","text":"cheb1_smat([T=Float64], n::Integer) where {T<:AbstractFloat}\n\nConstruct the synthesis matrix S that transforms Chebyshev coefficients to function values at Chebyshev points of the 2nd kind.\n\nArguments\n\nT: Element type (defaults to Float64)\nn: Number of points/coefficients\n\n\n\n\n\n","category":"method"},{"location":"cheb/#GRSuite.ChebSuite.cheb_clenshaw-Union{Tuple{T}, Tuple{AbstractVector{T}, T}} where T<:AbstractFloat","page":"Chebyshev Suite","title":"GRSuite.ChebSuite.cheb_clenshaw","text":"cheb_clenshaw(c::AbstractVector{T}, x::T) where {T<:AbstractFloat}\n\nEvaluate Chebyshev coefficients at a point using Clenshaw's algorithm.\n\nArguments\n\nc: Vector of Chebyshev coefficients c_0 c_1 ldots c_n\nx: Evaluation point in [-1,1]\n\nReferences\n\nchebfun/@chebtech/clenshaw.m at master · chebfun/chebfun\n\n\n\n\n\n","category":"method"},{"location":"cheb/#GRSuite.ChebSuite.cheb_coeffs_cumsummat-Union{Tuple{TR}, Tuple{Type{TR}, Integer}} where TR<:AbstractFloat","page":"Chebyshev Suite","title":"GRSuite.ChebSuite.cheb_coeffs_cumsummat","text":"cheb_coeffs_cumsummat([TR=Float64], n::Integer) where {TR<:AbstractFloat}\ncheb_coeffs_cumsummat([TR=Float64], n::Integer, x_min::TR, x_max::TR) where {TR<:AbstractFloat}\n\nGenerate the Chebyshev coefficient integration matrix that maps Chebyshev coefficients to the coefficients of the integral of the interpolating polynomial.\n\nArguments\n\nTR: Type parameter for the matrix elements (e.g., Float64)\nn: Size of the matrix (n×n)\nx_min: (Optional) Lower bound of the integration interval\nx_max: (Optional) Upper bound of the integration interval\n\nReferences\n\nchebfun/@chebcolloc1/chebcolloc1.m at master · chebfun/chebfun\nchebfun/@chebcolloc2/chebcolloc2.m at master · chebfun/chebfun\n\n\n\n\n\n","category":"method"},{"location":"cheb/#GRSuite.ChebSuite.cheb_diff!-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T<:AbstractFloat","page":"Chebyshev Suite","title":"GRSuite.ChebSuite.cheb_diff!","text":"cheb_diff(coeffs::AbstractVector{T}) where {T<:AbstractFloat}\ncheb_diff!(coeffs::AbstractVector{T}, coeffs_der::AbstractVector{T}) where {T<:AbstractFloat}\n\nCompute derivatives of Chebyshev coefficients.\n\nArguments\n\ncoeffs: Input vector of Chebyshev coefficients with length n\ncoeffs_der: Pre-allocated output vector for derivative coefficients (length at least n - 1)\n\n\n\n\n\n","category":"method"},{"location":"cheb/#GRSuite.ChebSuite.cheb_dissmat-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractMatrix{T}, AbstractMatrix{T}}} where T<:AbstractFloat","page":"Chebyshev Suite","title":"GRSuite.ChebSuite.cheb_dissmat","text":"cheb_dissmat(wts::AbstractVector{T}, S::AbstractMatrix{T}, A::AbstractMatrix{T}; negsum::Bool=true) where T<:AbstractFloat\n\nConstruct a dissipation matrix using precomputed weights and operators, optionally applying the 'negative sum trick', which seems make the simulation more stable according to my tests.\n\nArguments\n\nwts: Vector of dissipation weights\nS: First operator matrix\nA: Second operator matrix\nnegsum: Boolean flag for negative sum trick (default: true)\n\nThe function applies the weights through diagonal scaling and implements the negative sum trick for diagonal elements when negsum is true.\n\n\n\n\n\n","category":"method"},{"location":"cheb/#GRSuite.ChebSuite.cheb_disswts-Union{Tuple{T}, Tuple{Type{T}, Integer, Integer, Integer}} where T<:AbstractFloat","page":"Chebyshev Suite","title":"GRSuite.ChebSuite.cheb_disswts","text":"cheb_disswts([T=Float64], n::Integer, a::Integer, p::Integer) where {T<:AbstractFloat}\n\nCompute exponential dissipation weights for Chebyshev spectral methods [SLS09].\n\nw_k = e^-alphaleft(k  nright)^2 p quad k = 0 ldots n-1\n\nArguments\n\nT: Type parameter for floating-point precision\nn: Number of grid points\nα: Dissipation strength parameter\np: Order of dissipation\n\nSuggested values\n\nalpha = 36\nand p = 32 for weak dissipation [SLS09, HWB16]\nalpha = 40\nand p = 8 for strong dissipation [Rip23]\n\n\n\n\n\n","category":"method"},{"location":"cheb/#GRSuite.ChebSuite.cheb_feval-Union{Tuple{TR}, Tuple{AbstractVector{TR}, TR}} where TR<:AbstractFloat","page":"Chebyshev Suite","title":"GRSuite.ChebSuite.cheb_feval","text":"cheb_feval(f::AbstractVector{TR}, x::TR) where {TR<:AbstractFloat}\n\nEvaluate Chebyshev coefficients at a point.\n\nPerformance Notes\n\nClenshaw's algorithm: O(n) operations per point\n(TODO) NDCT: O(n log n) operations for many points simultaneously\n\nReferences\n\nchebfun/@chebtech/feval.m at master · chebfun/chebfun\n\n\n\n\n\n","category":"method"},{"location":"cheb/#GRSuite.ChebSuite.cheb_rectdiff1-Union{Tuple{TR}, Tuple{Type{TR}, Integer, Integer}} where TR<:AbstractFloat","page":"Chebyshev Suite","title":"GRSuite.ChebSuite.cheb_rectdiff1","text":"cheb_rectdiff1([TR=Float64], m::Integer, n::Integer) where {TR<:AbstractFloat}\ncheb_rectdiff1([TR=Float64], m::Integer, n::Integer, x_min::TR, x_max::TR) where {TR<:AbstractFloat}\n\nConstructing a 1st-order rectangular differentiation matrix mapping from a 1st-kind grid\n\nArguments:\n\nm : Size of the output grid (number of rows).\nn : Size of the input grid (number of columns).\n\nReferences\n\nchebfun/diffmat.m at master · chebfun/chebfun\n\n\n\n\n\n","category":"method"},{"location":"cheb/#GRSuite.ChebSuite.cheb_rectdiff2-Union{Tuple{TR}, Tuple{Type{TR}, Integer, Integer}} where TR<:AbstractFloat","page":"Chebyshev Suite","title":"GRSuite.ChebSuite.cheb_rectdiff2","text":"cheb_rectdiff2([TR=Float64], m::Integer, n::Integer) where {TR<:AbstractFloat}\ncheb_rectdiff2([TR=Float64], m::Integer, n::Integer, x_min::TR, x_max::TR) where {TR<:AbstractFloat}\n\nConstruct a 1st-order rectangular differentiation matrix mapping from a 2nd-kind grid.\n\nArguments:\n\nm : Size of the output grid (number of rows)\nn : Size of the input grid (number of columns)\n\nReferences\n\nchebfun/diffmat.m at master · chebfun/chebfun\n\n\n\n\n\n","category":"method"},{"location":"cheb/#GRSuite.ChebSuite.cheb_rectdiff_rec-Union{Tuple{TR}, Tuple{Type{TR}, Vararg{Integer, 4}}} where TR<:AbstractFloat","page":"Chebyshev Suite","title":"GRSuite.ChebSuite.cheb_rectdiff_rec","text":"cheb_rectdiff([TR=Float64], m::Integer, n::Integer, p::Integer, kind::Integer) where {TR<:AbstractFloat}\n\nConstruct a p-th order rectangular differentiation matrix mapping between Chebyshev grids.\n\nArguments\n\nm : Size of the output grid (number of rows)\nn : Size of the input grid (number of columns)\np : Order of differentiation\nkind : Kind of Chebyshev grid (1 or 2)\n\n\n\n\n\n","category":"method"},{"location":"cheb/#GRSuite.ChebSuite.cheb_rectint-Union{Tuple{TR}, Tuple{Type{TR}, Integer, Integer}} where TR<:AbstractFloat","page":"Chebyshev Suite","title":"GRSuite.ChebSuite.cheb_rectint","text":"cheb_rectint([TR=Float64], n::Integer) where {TR<:AbstractFloat}\ncheb_rectint([TR=Float64], n::Integer, x_min::TR, x_max::TR) where {TR<:AbstractFloat}\n\nGenerate the Chebyshev integration matrix that operates directly on function values.\n\nArguments\n\nTR: Type parameter for the matrix elements (e.g., Float64)\nn: Size of the matrix (n×n)\nx_min: (Optional) Lower bound of the integration interval\nx_max: (Optional) Upper bound of the integration interval\n\nReferences\n\nchebfun/intmat.m at master · chebfun/chebfun\n\n\n\n\n\n","category":"method"},{"location":"cheb/#GRSuite.ChebSuite.ultra_convertmat-Union{Tuple{T}, Tuple{Type{T}, Integer, Integer, Integer}} where T<:AbstractFloat","page":"Chebyshev Suite","title":"GRSuite.ChebSuite.ultra_convertmat","text":"ultra_convertmat([T=Float64], K1::Integer, K2::Integer, n::Integer) where {T<:AbstractFloat}\n\nConversion matrix used in the ultraspherical spectral method. Returns N-by-N matrix realization of conversion operator between ultraspherical polynomial bases. Maps N coefficients from C^{(K1)} basis to C^{(K2)} basis.\n\nReferences\n\nchebfun/@ultraS/convertmat.m at master · chebfun/chebfun\n\n\n\n\n\n","category":"method"},{"location":"cheb/#GRSuite.ChebSuite.ultra_diffmat-Union{Tuple{TI}, Tuple{TR}, Tuple{Type{TR}, TI, TI}} where {TR<:AbstractFloat, TI<:Integer}","page":"Chebyshev Suite","title":"GRSuite.ChebSuite.ultra_diffmat","text":"ultra_diffmat([TR=Float64], m::Integer, n::Integer) where TR<:AbstractFloat\n\nDifferentiation matrices for ultraspherical spectral method that takes n Chebyshev coefficients and returns n C^(m) coefficients that represent the derivative of the Chebyshev series. Here, C^(k) is the ultraspherical polynomial basis with parameter k.\n\nArguments\n\nm::Integer: Order of differentiation\nn::Integer: Number of points\n\nReferences\n\nchebfun/@ultraS/diffmat.m at master · chebfun/chebfun\n\n\n\n\n\n","category":"method"},{"location":"cheb/#GRSuite.ChebSuite.ultra_multmat-Union{Tuple{TR}, Tuple{AbstractVector{TR}, Integer}} where TR<:Union{AbstractFloat, Complex{<:AbstractFloat}}","page":"Chebyshev Suite","title":"GRSuite.ChebSuite.ultra_multmat","text":"ultra_multmat(coeffs::AbstractVector{TR}, λ::Integer) where {TR<:Union{AbstractFloat,Complex{<:AbstractFloat}}\n\nConstruct nxn multiplication matrix representing the multiplication of F in the C^(lambda) basis.\n\nArguments\n\ncoeffs::AbstractVector{TR} : Vector of Chebyshev coefficients\nλ::Integer : Order of the ultraspherical basis\n\nReferences\n\nchebfun/@ultraS/multmat.m at master · chebfun/chebfun\n\n\n\n\n\n","category":"method"},{"location":"cheb/#GRSuite.ChebSuite.ultra_spconvert-Union{Tuple{T}, Tuple{Type{T}, Integer, Integer}} where T<:AbstractFloat","page":"Chebyshev Suite","title":"GRSuite.ChebSuite.ultra_spconvert","text":"ultra_spconvert([T=Float64], λ::T, n::Integer) where {T<:AbstractFloat}\n\nCompute sparse representation for conversion operators. Returns the truncation of the operator that transforms C^lambda (Ultraspherical polynomials) to C^lambda + 1. The truncation gives back a matrix of size n x n.\n\nReferences\n\nchebfun/@ultraS/spconvert.m at master · chebfun/chebfun\n\n\n\n\n\n","category":"method"},{"location":"cheb/#GRSuite.ChebSuite.ultra_sphankel-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T<:Union{AbstractFloat, Complex{<:AbstractFloat}}","page":"Chebyshev Suite","title":"GRSuite.ChebSuite.ultra_sphankel","text":"sphankel(r::AbstractVector{T}) where {T<:Union{AbstractFloat,Complex{<:AbstractFloat}}\n\nConstruct a sparse Hankel matrix by forming it as an upside-down Toeplitz matrix. This is required by the ultraspherical multiplication operator.\n\nReferences\n\nchebfun/@ultraS/sphankel.m at master · chebfun/chebfun\n\n\n\n\n\n","category":"method"},{"location":"qnm/#QNM-Suite","page":"QNM Suite","title":"QNM Suite","text":"","category":"section"},{"location":"qnm/","page":"QNM Suite","title":"QNM Suite","text":"Modules = [GRSuite.QNMSuite]","category":"page"},{"location":"qnm/","page":"QNM Suite","title":"QNM Suite","text":"Modules = [GRSuite.QNMSuite]","category":"page"},{"location":"qnm/#GRSuite.QNMSuite.contfrac_lentz-Union{Tuple{T}, Tuple{Type{T}, Function, Function, T, Integer, Integer}} where T<:AbstractFloat","page":"QNM Suite","title":"GRSuite.QNMSuite.contfrac_lentz","text":"contfrac_lentz([T=Float64], a::Function, b::Function, tol::T, min_iter::Integer, max_iter::Integer) where {T<:AbstractFloat}\n\nCompute the continued fraction\n\nf(x)=b_0+fraca_1b_1+fraca_2b_2+fraca_3b_3+fraca_4b_4+fraca_5b_5+cdots\n\nusing modified Lentz's method. Translated from duetosymmetry/qnm.\n\nArguments\n\na: A function that returns the aᵢ terms.\nb: A function that returns the bᵢ terms.\ntol: The tolerance for convergence.\nmin_iter: The minimum number of iterations to perform.\nmax_iter: The maximum number of iterations to perform.\n\nReturns\n\nfᵢ: The value of the continued fraction.\nerrorᵢ: The estimated error.\ni: The number of iterations performed.\n\nExamples\n\nCompute the square root of two using continued fractions\n\nsqrt2 = 1 + frac12 + frac12 + frac12 + frac12 + cdots approx 1414213562373095\n\na(i) = 1\nb(i) = i == 0 ? 1 : 2\ncontfrac_lentz(Float64, a, b, 10*eps(Float64), 50, 1000)\n\nCompute Golden Ratio\n\nphi = 1 + frac11 + frac11 + frac11 + cdots approx 1618033988749895\n\na(i) = 1\nb(i) = 1\ncontfrac_lentz(Float64, a, b, 10*eps(Float64), 50, 1000)\n\nReferences\n\nqnm/qnm/contfrac.py at master · duetosymmetry/qnm\n[Pre07, Ste19, Len76, TB86, Tem24]\n\n\n\n\n\n","category":"method"},{"location":"fdm/#Finite-Difference-Suite","page":"Finite Difference Suite","title":"Finite Difference Suite","text":"","category":"section"},{"location":"fdm/","page":"Finite Difference Suite","title":"Finite Difference Suite","text":"Modules = [GRSuite.FDMSuite]","category":"page"},{"location":"fdm/","page":"Finite Difference Suite","title":"Finite Difference Suite","text":"Modules = [GRSuite.FDMSuite]","category":"page"},{"location":"fdm/#GRSuite.FDMSuite.fdm_boundnum-Tuple{Integer, Integer}","page":"Finite Difference Suite","title":"GRSuite.FDMSuite.fdm_boundnum","text":"fdm_boundnum(der_order::Integer, acc_order::Integer)\n\nCalculate the number of coefficients needed for shifted boundary FDM stencil.\n\nArguments\n\nder_order::Integer: Order of the derivative\nacc_order::Integer: Order of accuracy\n\n\n\n\n\n","category":"method"},{"location":"fdm/#GRSuite.FDMSuite.fdm_boundwts-Union{Tuple{T}, Tuple{Type{T}, Integer, Integer}} where T<:Real","page":"Finite Difference Suite","title":"GRSuite.FDMSuite.fdm_boundwts","text":"fdm_boundwts([T=Rational{TI}], der_order::TI, acc_order::TI) where {T<:Real, TI<:Integer}\n\nGenerate finite difference coefficients for shifted boundary conditions.\n\nArguments\n\nder_order::Integer: The order of the derivative to approximate\nacc_order::Integer: The desired order of accuracy\n\nReturns\n\nTuple of left and right shifted boundary finite difference coefficients The coefficients are stored in a matrix with the columns representing the different grid points. The columns are ordered from the leftmost grid point to the rightmost grid point.\n\n\n\n\n\n","category":"method"},{"location":"fdm/#GRSuite.FDMSuite.fdm_central-Union{Tuple{T}, Tuple{Type{T}, Integer, Integer}} where T<:Real","page":"Finite Difference Suite","title":"GRSuite.FDMSuite.fdm_central","text":"fdm_central([T=Rational{TI}], der_order::TI, acc_order::TI) where {T<:Real, TI<:Integer}\n\nGenerate central finite difference coefficients for a given derivative and accuracy order.\n\nArguments\n\nder_order::Integer: The order of the derivative to approximate\nacc_order::Integer: The desired order of accuracy (must be even)\n\nReturns\n\nVector of rational coefficients for the finite difference stencil\n\n\n\n\n\n","category":"method"},{"location":"fdm/#GRSuite.FDMSuite.fdm_centralnum-Tuple{Integer, Integer}","page":"Finite Difference Suite","title":"GRSuite.FDMSuite.fdm_centralnum","text":"fdm_centralnum(der_order::Integer, acc_order::Integer)\n\nCalculate the number of coefficients needed for central FDM stencil.\n\nArguments\n\nder_order::Integer: Order of the derivative\nacc_order::Integer: Order of accuracy\n\nReferences\n\nFinite difference coefficient - Wikipedia\n\n\n\n\n\n","category":"method"},{"location":"fdm/#GRSuite.FDMSuite.fdm_centralop-Union{Tuple{T}, Tuple{Integer, Integer, T}} where T<:AbstractFloat","page":"Finite Difference Suite","title":"GRSuite.FDMSuite.fdm_centralop","text":"fdm_centralop(der_order::Integer, acc_order::Integer, dx::T) where {T<:AbstractFloat}\n\nCreate a central finite difference operator with specified derivative order and accuracy.\n\nArguments\n\nder_order::Integer: The order of the derivative to approximate\nacc_order::Integer: The desired order of accuracy (must be even)\ndx::T: Grid spacing\n\n```\n\n\n\n\n\n","category":"method"},{"location":"fdm/#GRSuite.FDMSuite.fdm_dissop-Union{Tuple{T}, Tuple{Integer, T}} where T<:AbstractFloat","page":"Finite Difference Suite","title":"GRSuite.FDMSuite.fdm_dissop","text":"fdm_dissop(diss_order::Integer, dx::T) where {T<:AbstractFloat}\n\nCreate a finite difference dissipation operator with specified order.\n\nArguments\n\ndiss_order::Integer: The order of the dissipation operator\ndx::T: Grid spacing\n\n\n\n\n\n","category":"method"},{"location":"fdm/#GRSuite.FDMSuite.fdm_dissorder-Tuple{Integer}","page":"Finite Difference Suite","title":"GRSuite.FDMSuite.fdm_dissorder","text":"fdm_dissorder(acc_order::Integer)\n\nCalculate the order of dissipation needed for a given finite difference accuracy order [B+08]. For a scheme of accuracy order 2r-2, returns dissipation order 2r.\n\n\n\n\n\n","category":"method"},{"location":"fdm/#GRSuite.FDMSuite.fdm_disswts-Tuple{TI} where TI<:Integer","page":"Finite Difference Suite","title":"GRSuite.FDMSuite.fdm_disswts","text":"fdm_disswts(diss_order::Integer)\n\nCalculate the weights for Kreiss-Oliger dissipation of given order [B+08].\n\n\n\n\n\n","category":"method"},{"location":"fdm/#GRSuite.FDMSuite.fdm_extrapwts_left-Tuple{Int64}","page":"Finite Difference Suite","title":"GRSuite.FDMSuite.fdm_extrapwts_left","text":"fdm_extrapwts_left(extrap_order::Int)\n\nGenerate weights for left-sided extrapolation of order extrap_order.\n\nArguments\n\nextrap_order::Int: Order of extrapolation\n\nReturns\n\nVector of rational coefficients for left-sided extrapolation\n\n\n\n\n\n","category":"method"},{"location":"fdm/#GRSuite.FDMSuite.fdm_extrapwts_right-Tuple{Int64}","page":"Finite Difference Suite","title":"GRSuite.FDMSuite.fdm_extrapwts_right","text":"fdm_extrapwts_right(extrap_order::Int)\n\nGenerate weights for right-sided extrapolation of order extrap_order.\n\nArguments\n\nextrap_order::Int: Order of extrapolation\n\nReturns\n\nVector of rational coefficients for right-sided extrapolation\n\n\n\n\n\n","category":"method"},{"location":"fdm/#GRSuite.FDMSuite.fdm_fornbergwts-Union{Tuple{T}, Tuple{Integer, T, AbstractVector{T}}} where T<:Real","page":"Finite Difference Suite","title":"GRSuite.FDMSuite.fdm_fornbergwts","text":"fdm_fornbergwts([T=Float64], order::Integer, x0::Real, x::AbstractVector; \n                         dfdx::Bool=false)\n\nCalculate finite difference weights for arbitrary-order derivatives using the Fornberg algorithm. Taken from SciML/MethodOfLines.jl.\n\nArguments\n\nT: Type parameter for the weights (defaults to type of x0)\norder: Order of the derivative to approximate\nx0: Point at which to approximate the derivative\nx: Grid points to use in the approximation\ndfdx: Whether to include first derivative values (Hermite finite differences)\n\nReturns\n\nIf dfdx == false:\n\nVector{T}: Weights for function values\n\nIf dfdx == true:\n\nTuple{Vector{T}, Vector{T}}: Weights for (function values, derivative values)\n\nMathematical Background\n\nFor a function f(x), the derivative approximation takes the form:\n\nIf dfdx == false (standard finite differences):\n\nf^(n)(x_0) approx sum_j=1^N c_j f(x_j)\n\nIf dfdx == true (Hermite finite differences):\n\nf^(n)(x_0) approx sum_j=1^N d_j f(x_j) + e_j f(x_j)\n\nRequirements\n\nFor standard finite differences: N > order\nFor Hermite finite differences: N > order/2 + 1\n\nwhere N is the length of x\n\nExamples\n\n# Standard central difference for first derivative\nx = [-1.0, 0.0, 1.0]\nw = fdm_fornbergwts(1, 0.0, x)\n# Returns approximately [-0.5, 0.0, 0.5]\n\n# Forward difference for second derivative\nx = [0.0, 1.0, 2.0, 3.0]\nw = fdm_fornbergwts(2, 0.0, x)\n\n# Hermite finite difference for third derivative\nx = [-1.0, 0.0, 1.0]\nw_f, w_d = fdm_fornbergwts(3, 0.0, x, dfdx=true)\n\nReferences\n\nMethodOfLines.jl/src/discretization/schemes/fdm_fornbergwts.jl at master · SciML/MethodOfLines.jl\nFornberg [For88]\nFornberg [For21]\nFornberg [For98]\nprecision - Numerical derivative and finite difference coefficients: any update of the Fornberg method? - Computational Science Stack Exchange\n\n\n\n\n\n","category":"method"},{"location":"fdm/#GRSuite.FDMSuite.fdm_grid-Union{Tuple{T}, Tuple{T, T, T}} where T<:AbstractFloat","page":"Finite Difference Suite","title":"GRSuite.FDMSuite.fdm_grid","text":"fdm_grid(x_min::T, x_max::T, dx::T) where {T<:AbstractFloat}\n\nGenerate a uniform grid for finite difference methods.\n\nArguments\n\nx_min: Lower bound of the interval\nx_max: Upper bound of the interval\ndx: Grid spacing\n\nReturns\n\nVector of n uniformly spaced points, where n = round((xmax - xmin)/dx) + 1\n\n\n\n\n\n","category":"method"},{"location":"fdm/#GRSuite.FDMSuite.fdm_hermite-Union{Tuple{T}, Tuple{Type{T}, Integer, Integer}} where T<:Real","page":"Finite Difference Suite","title":"GRSuite.FDMSuite.fdm_hermite","text":"fdm_hermite([T=Rational{TI}], der_order::TI, acc_order::TI) where {T<:Real, TI<:Integer}\n\nGenerate Hermite-type finite difference coefficients that include function value and derivative information.\n\nArguments\n\nder_order::Integer: The order of the derivative to approximate (must be ≥ 2)\nacc_order::Integer: The desired order of accuracy\nFor derorder 2,3,6,7,10,11...: accorder must be 4,8,12...\nFor derorder 4,5,8,9,12...: accorder must be 2,6,10...\n\nReturns\n\nVector of rational coefficients for the Hermite-type finite difference stencil\n\n\n\n\n\n","category":"method"},{"location":"fdm/#GRSuite.FDMSuite.fdm_hermitenum-Tuple{Integer, Integer}","page":"Finite Difference Suite","title":"GRSuite.FDMSuite.fdm_hermitenum","text":"fdm_hermitenum(der_order::Integer, acc_order::Integer)\n\nCalculate the number of coefficients needed for Hermite FDM stencil.\n\nArguments\n\nder_order::Integer: Order of the derivative\nacc_order::Integer: Order of accuracy\n\nReferences\n\nFornberg [For21]\n\n\n\n\n\n","category":"method"},{"location":"fdm/#GRSuite.FDMSuite.fdm_hermiteop-Union{Tuple{T}, Tuple{Integer, Integer, T}} where T<:AbstractFloat","page":"Finite Difference Suite","title":"GRSuite.FDMSuite.fdm_hermiteop","text":"fdm_hermiteop(der_order::Integer, acc_order::Integer, dx::T) where {T<:AbstractFloat}\n\nCreate a Hermite finite difference operator with specified derivative order and accuracy.\n\nArguments\n\nder_order::Integer: The order of the derivative to approximate\nacc_order::Integer: The desired order of accuracy (must be even)\ndx::T: Grid spacing\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = GRSuite","category":"page"},{"location":"#GRSuite","page":"Home","title":"GRSuite","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for GRSuite.","category":"page"},{"location":"","page":"Home","title":"Home","text":"warning: Warning\nI'm still actively developing it and migrating code from private repositories to this one, so it may currently lack some features.","category":"page"},{"location":"#Motivation-and-Purpose","page":"Home","title":"Motivation and Purpose","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"After developing hundreds of PDE solvers for various projects, I decided to create GRSuite.jl because I couldn't find a library that was both highly convenient and effective for solving partial differential equations (PDEs) in the context of general relativity (GR).","category":"page"},{"location":"","page":"Home","title":"Home","text":"When solving GR PDEs in spherical symmetry or even axisymmetry, the requirements are often far more demanding than in 3+1 cases. These include the need for very long-time simulations, conservation of quantities, highly accurate late-time behavior, and precise computation of quasinormal modes. While I have addressed these challenges individually in the past, I grew tired of copying and pasting solutions from old repositories. Instead, I decided to develop a comprehensive, feature-rich, and highly efficient library. This is my answer to those challenges.","category":"page"},{"location":"#Description","page":"Home","title":"Description","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"GRSuite.jl is a high-performance suite designed to compute arbitrary-precision solutions of PDEs in GR. It is planned to support solving the following built-in equations (some of which were developed for previous projects and will be ported to this library):","category":"page"},{"location":"","page":"Home","title":"Home","text":"Spherical Symmetry\n[ ] Regge-Wheeler-Zerilli equation in hyperboloidal, Kerr-Schild, and tortoise coordinates\n[ ] Klein-Gordon equation in hyperboloidal, Kerr-Schild, and tortoise coordinates\n[ ] Einstein equations with a scalar field using the Z4 formulation\nAxisymmetry\n[ ] Teukolsky equation in hyperboloidal, Kerr-Schild, and tortoise coordinates\n[ ] Klein-Gordon equation in hyperboloidal, Kerr-Schild, and tortoise coordinates\nQuasinormal Modes\n[ ] Compute quasinormal modes for the Schwarzschild black hole using the Regge-Wheeler-Zerilli equation. Use the continued fraction method to determine the eigenvalue and the ultraspherical spectral method in hyperboloidal coordinates to determine the eigenfunction.\n[ ] Compute quasinormal modes for the Teukolsky equation using the continued fraction method. Apply the Cook-Zalutskiy spectral approach for the angular sector to determine the eigenvalue and the ultraspherical spectral method in hyperboloidal coordinates to determine the eigenfunction.","category":"page"},{"location":"","page":"Home","title":"Home","text":"GRSuite.jl currently includes utilities for the following numerical methods:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Spatial Discretization\n[x] Chebyshev collocation at Chebyshev points of the first and second kinds (Most of algorithms are translated from Chebfun)\n[x] Finite difference method\n[x] Hermite finite difference method\n[x] Rectangular collocation method (Most of algorithms are translated from Chebfun)\n[x] Ultraspherical spectral method (Most of algorithms are translated from Chebfun)\n[ ] Ultraspherical rectangular collocation\nQuasinormal Mode Computation\n[x] Modified Lentz method for continued fractions\nGeneral Utilities\n[x] Correctly rounded floating-point dot/sum using xsum or Kahan summation","category":"page"},{"location":"","page":"Home","title":"Home","text":"While the ChebyshevSuite is inspired by algorithms from Chebfun, it has been significantly enhanced in this package to improve performance and support arbitrary-precision calculations.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This project is under active development, so feel free to give it a try!","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [GRSuite]","category":"page"},{"location":"utils/#General-Utilities","page":"Utilities","title":"General Utilities","text":"","category":"section"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"Modules = [GRSuite.Utils]","category":"page"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"Modules = [GRSuite.Utils]","category":"page"},{"location":"utils/#GRSuite.Utils.dot_kahan-Union{Tuple{T}, Tuple{StridedVector{T}, StridedVector{T}}} where T<:Number","page":"Utilities","title":"GRSuite.Utils.dot_kahan","text":"dot_kahan(v1::StridedVector{T}, v2::StridedVector{T}) where {T<:Number}\n\nCompute the dot product using Kahan summation algorithm to reduce numerical errors.\n\nNote\n\nSlower than dot_xsum for large vectors, but faster for small vectors.\nSimilar performance to dot_kahan_neumaier\nBoth input vectors must have the same length, which is not checked for performance reasons.\n\n\n\n\n\n","category":"method"},{"location":"utils/#GRSuite.Utils.dot_kahan_neumaier-Union{Tuple{T}, Tuple{StridedVector{T}, StridedVector{T}}} where T<:Number","page":"Utilities","title":"GRSuite.Utils.dot_kahan_neumaier","text":"dot_kahan_neumaier(v1::StridedVector{T}, v2::StridedVector{T}) where {T<:Number}\n\nNeumaier's variant of Kahan summation algorithm to reduce numerical errors.\n\nNote\n\nSlower than dot_xsum for large vectors, but faster for small vectors.\nSimilar performance to dot_kahan\nUses loop unrolling for better performance while maintaining Kahan summation's\n\nnumerical stability. Processes two elements per iteration when possible.\n\nReferences\n\nJuliaMath/KahanSummation.jl\n\n\n\n\n\n","category":"method"},{"location":"utils/#GRSuite.Utils.dot_xsum-Tuple{StridedVector{Float64}, StridedVector{Float64}}","page":"Utilities","title":"GRSuite.Utils.dot_xsum","text":"dot_xsum(x::StridedVector{T}, y::StridedVector{T}) where {T<:Real}\n\nCompute the dot product of two vectors using extended precision accumulation. Uses the xsum package for improved numerical accuracy.\n\nNote\n\nVery fast for large vectors, but a bit slower than Kahan summation for small vectors.\nBoth input vectors must have the same length, which is not checked for performance reasons.\n\nReferences\n\nNeal [Nea15]\nJuliaMath/Xsum.jl\nRadford Neal / xsum · GitLab\n\n\n\n\n\n","category":"method"},{"location":"utils/#GRSuite.Utils.sum_kahan-Union{Tuple{StridedVector{T}}, Tuple{T}} where T<:Number","page":"Utilities","title":"GRSuite.Utils.sum_kahan","text":"sum_kahan(v::StridedVector{T}) where {T<:Number}\n\nCompute the sum using Kahan summation algorithm to reduce numerical errors.\n\nNote\n\nSlower than sum_xsum for large vectors, but faster for small vectors.\nSimilar performance to sum_kahan_neumaier\n\n\n\n\n\n","category":"method"},{"location":"utils/#GRSuite.Utils.sum_kahan_neumaier-Union{Tuple{StridedVector{T}}, Tuple{T}} where T<:Number","page":"Utilities","title":"GRSuite.Utils.sum_kahan_neumaier","text":"sum_kahan_neumaier(v::StridedVector{T}) where {T<:Number}\n\nNeumaier's variant of Kahan summation algorithm to reduce numerical errors.\n\nNote\n\nSlower than sum_xsum for large vectors, but faster for small vectors.\nSimilar performance to sum_kahan\nUses loop unrolling for better performance while maintaining Kahan summation's\n\nnumerical stability. Processes two elements per iteration when possible.\n\nReferences\n\nJuliaMath/KahanSummation.jl\n\n\n\n\n\n","category":"method"},{"location":"utils/#GRSuite.Utils.sum_xsum-Tuple{StridedVector{Float64}}","page":"Utilities","title":"GRSuite.Utils.sum_xsum","text":"sum_xsum(vec::StridedVector{T}) where {T<:Union{Float32,Float64}}\n\nCompute the sum of a vector using extended precision accumulation. Uses the xsum package for improved numerical accuracy.\n\nNote\n\nVery fast for large vectors, but a bit slower than Kahan summation for small vectors (n ⪅ 80)\n\nReferences\n\nNeal [Nea15]\nJuliaMath/Xsum.jl\nRadford Neal / xsum · GitLab\n\n\n\n\n\n","category":"method"}]
}
