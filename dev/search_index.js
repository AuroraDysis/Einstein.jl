var documenterSearchIndex = {"docs":
[{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"J. L. Aurentz and L. N. Trefethen. Chopping a Chebyshev Series (2015), arXiv:1512.01803 [math.NA].\n\n\n\nM. C. Babiuc and others. Implementation of standard testbeds for numerical relativity. Class. Quant. Grav. 25, 125012 (2008), arXiv:0709.3559 [gr-qc].\n\n\n\nR. Baltensperger and M. R. Trummer. Spectral Differencing with a Twist. SIAM Journal on Scientific Computing 24, 1465–1487 (2003), arXiv:https://doi.org/10.1137/S1064827501388182.\n\n\n\nJ.-P. Berrut and L. N. Trefethen. Barycentric lagrange interpolation. SIAM review 46, 501–517 (2004).\n\n\n\nJ.-P. Berrut and L. N. Trefethen. Barycentric Lagrange Interpolation. SIAM Review 46, 501–517 (2004), arXiv:https://doi.org/10.1137/S0036144502417715.\n\n\n\nG. B. Cook and M. Zalutskiy. Gravitational perturbations of the Kerr geometry: High-accuracy study. Phys. Rev. D 90, 124021 (2014), arXiv:1410.7698 [gr-qc].\n\n\n\nS. R. Dolan and A. C. Ottewill. On an Expansion Method for Black Hole Quasinormal Modes and Regge Poles. Class. Quant. Grav. 26, 225003 (2009), arXiv:0908.0329 [gr-qc].\n\n\n\nB. Fornberg. Generation of finite difference formulas on arbitrarily spaced grids. Mathematics of computation 51, 699–706 (1988).\n\n\n\nB. Fornberg. Classroom Note:Calculation of Weights in Finite Difference Formulas. SIAM Review 40, 685–691 (1998), arXiv:https://doi.org/10.1137/S0036144596322507.\n\n\n\nB. Fornberg. An algorithm for calculating Hermite-based finite difference weights. IMA Journal of Numerical Analysis 41, 801–813 (2021).\n\n\n\nD. Hilditch, A. Weyhausen and B. Brügmann. Pseudospectral method for gravitational wave collapse. Phys. Rev. D 93, 063006 (2016), arXiv:1504.04732 [gr-qc].\n\n\n\nW. J. Lentz. Generating Bessel functions in Mie scattering calculations using continued fractions. Applied optics 15, 668–671 (1976).\n\n\n\nV. Mehrmann and H. Voss. Nonlinear eigenvalue problems: A challenge for modern eigenvalue methods. GAMM-Mitteilungen 27, 121–152 (2004).\n\n\n\nR. M. Neal. Fast exact summation using small and large superaccumulators (2015), arXiv:1505.05571 [cs.NA].\n\n\n\nW. H. Press. Numerical recipes 3rd edition: The art of scientific computing (Cambridge university press, 2007).\n\n\n\nJ. Ripley. *JLRipley314/teuk-fortran-2020: Teuk-                Fortran-2020-v1.1                * (Aug 2023).\n\n\n\nL. C. Stein, qnm: A Python package for calculating Kerr quasinormal modes, separation constants, and spherical-spheroidal mixing coefficients. J. Open Source Softw. 4, 1683 (2019), arXiv:1908.10377 [gr-qc].\n\n\n\nB. Szilagyi, L. Lindblom and M. A. Scheel. Simulations of Binary Black Hole Mergers Using Spectral Methods. Phys. Rev. D 80, 124010 (2009), arXiv:0909.3557 [gr-qc].\n\n\n\nN. M. Temme. DLMF: §3.10 Continued Fractions ‣ Areas ‣ Chapter 3 Numerical Methods, https://dlmf.nist.gov/3.10 (09 2024) (Accessed on 09/19/2024).\n\n\n\nI. J. Thompson and A. R. Barnett. Coulomb and Bessel functions of complex arguments and order. Journal of Computational Physics 64, 490–509 (1986).\n\n\n\n","category":"page"},{"location":"cheb/#Chebyshev-Suite","page":"Chebyshev Suite","title":"Chebyshev Suite","text":"","category":"section"},{"location":"cheb/","page":"Chebyshev Suite","title":"Chebyshev Suite","text":"Modules = [Einstein.ChebyshevSuite]","category":"page"},{"location":"cheb/","page":"Chebyshev Suite","title":"Chebyshev Suite","text":"Modules = [Einstein.ChebyshevSuite]","category":"page"},{"location":"cheb/#Einstein.ChebyshevSuite.ChebyshevGaussCoeffs2ValsPlan","page":"Chebyshev Suite","title":"Einstein.ChebyshevSuite.ChebyshevGaussCoeffs2ValsPlan","text":"cheb_gauss_coeffs2vals(coeffs::AbstractVector{TFC}) where {TFC<:Union{AbstractFloat,Complex{<:AbstractFloat}}}\ncheb_gauss_coeffs2vals_plan([TFC=Float64], n::Integer)(coeffs::AbstractVector{TFC}) where {TFC<:Union{AbstractFloat,Complex{<:AbstractFloat}}}\n\nConvert Chebyshev coefficients to values at Chebyshev points of the 1st kind.\n\nPerformance Guide\n\nFor best performance, especially in loops or repeated calls:\n\nplan = cheb_gauss_coeffs2vals_plan(Float64, n)\nvalues = plan * coeffs\n\nReferences\n\nchebfun/@chebtech1/coeffs2vals.m at master · chebfun/chebfun\n\n\n\n\n\n","category":"type"},{"location":"cheb/#Einstein.ChebyshevSuite.ChebyshevGaussVals2CoeffsPlan","page":"Chebyshev Suite","title":"Einstein.ChebyshevSuite.ChebyshevGaussVals2CoeffsPlan","text":"cheb_gauss_vals2coeffs(vals::AbstractVector{TF}) where {TF<:AbstractFloat}\ncheb_gauss_vals2coeffs_plan([TFC=Float64], n::Integer)(vals::AbstractVector{TFC}) where {TFC<:Union{AbstractFloat,Complex{<:AbstractFloat}}}\n\nConvert values at Chebyshev points of the 1st kind into Chebyshev coefficients.\n\nPerformance Guide\n\nFor best performance, especially in loops or repeated calls:\n\nplan = cheb_gauss_vals2coeffs_plan(Float64, n)\ncoeffs = plan * values\n\nReferences\n\nchebfun/@chebtech1/vals2coeffs.m at master · chebfun/chebfun\n\n\n\n\n\n","category":"type"},{"location":"cheb/#Einstein.ChebyshevSuite.ChebyshevLobattoCoeffs2ValsPlan","page":"Chebyshev Suite","title":"Einstein.ChebyshevSuite.ChebyshevLobattoCoeffs2ValsPlan","text":"cheb_lobatto_coeffs2vals(coeffs::AbstractVector{TFC}) where {TFC<:Union{AbstractFloat,Complex{<:AbstractFloat}}}\ncheb_lobatto_coeffs2vals_plan([TFC=Float64], n::Integer)(coeffs::AbstractVector{TFC}) where {TFC<:Union{AbstractFloat,Complex{<:AbstractFloat}}}\n\nConvert Chebyshev coefficients to values at Chebyshev points of the 2nd kind.\n\nPerformance Guide\n\nFor best performance, especially in loops or repeated calls:\n\nplan = cheb_lobatto_coeffs2vals_plan(Float64, n)\nvalues = plan * coeffs\n\nReferences\n\nchebfun/@chebtech2/coeffs2vals.m at master · chebfun/chebfun\n\n\n\n\n\n","category":"type"},{"location":"cheb/#Einstein.ChebyshevSuite.ChebyshevLobattoVals2CoeffsPlan","page":"Chebyshev Suite","title":"Einstein.ChebyshevSuite.ChebyshevLobattoVals2CoeffsPlan","text":"cheb_lobatto_vals2coeffs(vals::AbstractVector{TFC}) where {TFC<:Union{AbstractFloat,Complex{<:AbstractFloat}}}\ncheb_lobatto_vals2coeffs_plan([TFC=Float64], n::Integer)(vals::AbstractVector{TFC}) where {TFC<:Union{AbstractFloat,Complex{<:AbstractFloat}}}\n\nConvert values at Chebyshev points of the 2nd kind into Chebyshev coefficients.\n\nPerformance Guide\n\nFor best performance, especially in loops or repeated calls:\n\nplan = cheb_lobatto_vals2coeffs_plan(Float64, n)\ncoeffs = plan * values\n\nReferences\n\nchebfun/@chebtech2/vals2coeffs.m at master · chebfun/chebfun\n\n\n\n\n\n","category":"type"},{"location":"cheb/#Einstein.ChebyshevSuite.cheb_filter_matrix-Union{Tuple{TF}, Tuple{AbstractVector{TF}, AbstractMatrix{TF}, AbstractMatrix{TF}}} where TF<:AbstractFloat","page":"Chebyshev Suite","title":"Einstein.ChebyshevSuite.cheb_filter_matrix","text":"cheb_filter_matrix(weights::AbstractVector{TF}, S::AbstractMatrix{TF}, A::AbstractMatrix{TF}; negsum::Bool=true) where TF<:AbstractFloat\n\nConstruct a filter matrix using precomputed weights and operators for Chebyshev collocation methods, optionally applying the 'negative sum trick', which seems make the simulation more stable according to my tests.\n\nArguments\n\nweights: Vector of filter weights\nS: Chebyshev synthesis matrix: maps Chebyshev series to function values at Chebyshev grid points\nA: Chebyshev analysis matrix: maps function values at Chebyshev grid points to Chebyshev series\nnegative_sum_trick: Boolean flag for negative sum trick (default: true)\n\nThe function applies the weights through diagonal scaling and implements the negative sum trick for diagonal elements when negative_sum_trick is true.\n\n\n\n\n\n","category":"method"},{"location":"cheb/#Einstein.ChebyshevSuite.cheb_gauss_angles-Union{Tuple{TF}, Tuple{Type{TF}, Integer}} where TF<:AbstractFloat","page":"Chebyshev Suite","title":"Einstein.ChebyshevSuite.cheb_gauss_angles","text":"cheb_gauss_angles(TF, n) where {TF<:AbstractFloat}\n\nCompute angles for Chebyshev points of the 1st kind:\n\ntheta_k = frac(2k + 1)pi2n quad k = n-1ldots0\n\nArguments\n\nTF: Type parameter for the angles (e.g., Float64)\nn: Number of points\n\n\n\n\n\n","category":"method"},{"location":"cheb/#Einstein.ChebyshevSuite.cheb_gauss_barycentric_weights-Union{Tuple{TF}, Tuple{Type{TF}, Integer}} where TF<:AbstractFloat","page":"Chebyshev Suite","title":"Einstein.ChebyshevSuite.cheb_gauss_barycentric_weights","text":"cheb_gauss_barycentric_weights([TF=Float64], n::Integer) where {TF<:AbstractFloat}\n\nCompute the barycentric weights for Chebyshev points of the 1st kind.\n\nArguments\n\nTF: Type parameter for the weights (defaults to Float64)\nn: Number of points\n\nReferences\n\nBerrut and Trefethen [BT04a]\nchebfun/@chebtech1/barywts.m at master · chebfun/chebfun\n\nSee also: BarycentricInterpolation\n\n\n\n\n\n","category":"method"},{"location":"cheb/#Einstein.ChebyshevSuite.cheb_gauss_coeffs2vals_matrix-Union{Tuple{TF}, Tuple{Type{TF}, Integer}} where TF<:AbstractFloat","page":"Chebyshev Suite","title":"Einstein.ChebyshevSuite.cheb_gauss_coeffs2vals_matrix","text":"cheb_gauss_coeffs2vals_matrix([TF=Float64], n::Integer) where {TF<:AbstractFloat}\n\nConstruct the synthesis matrix S that transforms Chebyshev coefficients to function values at Chebyshev points of the 1st kind.\n\nArguments\n\nTF: Element type (defaults to Float64)\nn: Number of points/coefficients\n\n\n\n\n\n","category":"method"},{"location":"cheb/#Einstein.ChebyshevSuite.cheb_gauss_differentiation_matrix-Union{Tuple{TR}, Tuple{Type{TR}, Integer}, Tuple{Type{TR}, Integer, Integer}} where TR<:AbstractFloat","page":"Chebyshev Suite","title":"Einstein.ChebyshevSuite.cheb_gauss_differentiation_matrix","text":"cheb_gauss_differentiation_matrix([TR=Float64], n::Integer, k::Integer=1) where {TR<:AbstractFloat}\n\nConstruct a Chebyshev differentiation that maps function values at n Chebyshev points of the 1st kind  to values of the k-th derivative of the interpolating polynomial at those points.\n\nArguments\n\nTR: Element type (defaults to Float64)\nn::Integer: Number of Chebyshev points\nk::Integer=1: Order of the derivative (default: 1)\n\nReferences\n\nchebfun/@chebcolloc1/chebcolloc1.m at master · chebfun/chebfun\n\n\n\n\n\n","category":"method"},{"location":"cheb/#Einstein.ChebyshevSuite.cheb_gauss_integration_matrix-Union{Tuple{TF}, Tuple{Type{TF}, Integer}} where TF<:AbstractFloat","page":"Chebyshev Suite","title":"Einstein.ChebyshevSuite.cheb_gauss_integration_matrix","text":"cheb_gauss_integration_matrix([TF=Float64], n::Integer) where {TF<:AbstractFloat}\ncheb_gauss_integration_matrix([TF=Float64], n::Integer, lower_bound::TF, upper_bound::TF) where {TF<:AbstractFloat}\n\nCompute Chebyshev integration matrix that maps function values at n Chebyshev points of the 1st kind to values of the integral of the interpolating polynomial at those points, with the convention that the first value is zero.\n\nReferences\n\nchebfun/@chebcolloc1/chebcolloc1.m at master · chebfun/chebfun\n\n\n\n\n\n","category":"method"},{"location":"cheb/#Einstein.ChebyshevSuite.cheb_gauss_points-Union{Tuple{TF}, Tuple{Type{TF}, Integer}} where TF<:AbstractFloat","page":"Chebyshev Suite","title":"Einstein.ChebyshevSuite.cheb_gauss_points","text":"cheb_gauss_points([TF=Float64], n::Integer) where {TF<:AbstractFloat}\ncheb_gauss_points([TF=Float64], n::Integer, lower_bound::TF, upper_bound::TF) where {TF<:AbstractFloat}\n\nGenerate Chebyshev points of the 2nd kind.\n\nFor the standard interval [-1,1]:\n\nx_k = -cosleft(frac(2k + 1)pi2nright) quad k = 01ldotsn-1\n\nFor mapped interval [lowerbound,upperbound]:\n\nx_mathrmmapped = fracx_mathrmmax + x_mathrmmin2 + fracx_mathrmmin - x_mathrmmax2x_k\n\nArguments\n\nTF: Type parameter for the grid points (e.g., Float64)\nn: Number of points\nlower_bound: (Optional) Lower bound of the mapped interval\nupper_bound: (Optional) Upper bound of the mapped interval\n\nReferences\n\nchebfun/@chebtech1/chebpts.m at master · chebfun/chebfun\n\n\n\n\n\n","category":"method"},{"location":"cheb/#Einstein.ChebyshevSuite.cheb_gauss_quadrature_weights-Union{Tuple{TF}, Tuple{Type{TF}, Integer}} where TF<:AbstractFloat","page":"Chebyshev Suite","title":"Einstein.ChebyshevSuite.cheb_gauss_quadrature_weights","text":"cheb_gauss_quadrature_weights([TF=Float64], n::Integer) where {TF<:AbstractFloat}\n\nCompute quadrature weights for Chebyshev points of the 1st kind.\n\nArguments\n\nTF: Type parameter for the weights (e.g., Float64)\nn: Number of points\n\nReferences\n\nchebfun/@chebtech1/quadwts.m at master · chebfun/chebfun\n\n\n\n\n\n","category":"method"},{"location":"cheb/#Einstein.ChebyshevSuite.cheb_gauss_vals2coeffs_matrix-Union{Tuple{TF}, Tuple{Type{TF}, Integer}} where TF<:AbstractFloat","page":"Chebyshev Suite","title":"Einstein.ChebyshevSuite.cheb_gauss_vals2coeffs_matrix","text":"cheb_gauss_vals2coeffs_matrix([TF=Float64], n::Integer) where {TF<:AbstractFloat}\n\nConstruct the analysis matrix A that transforms function values at Chebyshev points of the 1st kind to Chebyshev coefficients.\n\nArguments\n\nTF: Element type (defaults to Float64)\nn: Number of points/coefficients\n\n\n\n\n\n","category":"method"},{"location":"cheb/#Einstein.ChebyshevSuite.cheb_lobatto_angles-Union{Tuple{TF}, Tuple{Type{TF}, Integer}} where TF<:AbstractFloat","page":"Chebyshev Suite","title":"Einstein.ChebyshevSuite.cheb_lobatto_angles","text":"cheb_lobatto_angles(TF, n) where {TF<:AbstractFloat}\n\nCompute angles for Chebyshev points of the 2nd kind:\n\ntheta_k = frackpin-1 quad k = n-1ldots0\n\nArguments\n\nTF: Type parameter for the angles (e.g., Float64)\nn: Number of points\n\n\n\n\n\n","category":"method"},{"location":"cheb/#Einstein.ChebyshevSuite.cheb_lobatto_barycentric_weights-Union{Tuple{TF}, Tuple{Type{TF}, Integer}} where TF<:AbstractFloat","page":"Chebyshev Suite","title":"Einstein.ChebyshevSuite.cheb_lobatto_barycentric_weights","text":"cheb_lobatto_barycentric_weights([TF=Float64], n::Integer) where {TF<:AbstractFloat}\n\nCompute the barycentric weights for Chebyshev points of the 2nd kind.\n\nArguments\n\nTF: Type parameter for the weights (e.g., Float64)\nn: Number of points\n\nReferences\n\nchebfun/@chebtech2/barywts.m at master · chebfun/chebfun\n\nSee also: BarycentricInterpolation\n\n\n\n\n\n","category":"method"},{"location":"cheb/#Einstein.ChebyshevSuite.cheb_lobatto_coeffs2vals_matrix-Union{Tuple{TF}, Tuple{Type{TF}, Integer}} where TF<:AbstractFloat","page":"Chebyshev Suite","title":"Einstein.ChebyshevSuite.cheb_lobatto_coeffs2vals_matrix","text":"cheb_lobatto_coeffs2vals_matrix([TF=Float64], n::Integer) where {TF<:AbstractFloat}\n\nConstruct the synthesis matrix S that transforms Chebyshev coefficients to function values at Chebyshev points of the 2nd kind.\n\nArguments\n\nTF: Element type (defaults to Float64)\nn: Number of points/coefficients\n\n\n\n\n\n","category":"method"},{"location":"cheb/#Einstein.ChebyshevSuite.cheb_lobatto_differentiation_matrix-Union{Tuple{TR}, Tuple{Type{TR}, Integer}, Tuple{Type{TR}, Integer, Integer}} where TR<:AbstractFloat","page":"Chebyshev Suite","title":"Einstein.ChebyshevSuite.cheb_lobatto_differentiation_matrix","text":"cheb_lobatto_differentiation_matrix([TR=Float64], n::Integer, k::Integer=1) where {TR<:AbstractFloat}\n\nConstruct a Chebyshev differentiation that maps function values at n Chebyshev points of the 2nd kind  to values of the k-th derivative of the interpolating polynomial at those points.\n\nArguments\n\nTR: Element type (defaults to Float64)\nn::Integer: Number of Chebyshev points\nk::Integer=1: Order of the derivative (default: 1)\n\nReferences\n\nchebfun/@chebcolloc2/chebcolloc2.m at master · chebfun/chebfun\n\n\n\n\n\n","category":"method"},{"location":"cheb/#Einstein.ChebyshevSuite.cheb_lobatto_integration_matrix-Union{Tuple{TF}, Tuple{Type{TF}, Integer}} where TF<:AbstractFloat","page":"Chebyshev Suite","title":"Einstein.ChebyshevSuite.cheb_lobatto_integration_matrix","text":"cheb_lobatto_integration_matrix([TF=Float64], n::Integer) where {TF<:AbstractFloat}\ncheb_lobatto_integration_matrix([TF=Float64], n::Integer, lower_bound::TF, upper_bound::TF) where {TF<:AbstractFloat}\n\nCompute Chebyshev integration matrix that maps function values at n Chebyshev points of the 2st kind to values of the integral of the interpolating polynomial at those points, with the convention that the first value is zero.\n\nReferences\n\nchebfun/@chebcolloc2/chebcolloc2.m at master · chebfun/chebfun\n\n\n\n\n\n","category":"method"},{"location":"cheb/#Einstein.ChebyshevSuite.cheb_lobatto_points-Union{Tuple{TF}, Tuple{Type{TF}, Integer}} where TF<:AbstractFloat","page":"Chebyshev Suite","title":"Einstein.ChebyshevSuite.cheb_lobatto_points","text":"cheb_lobatto_points([TF=Float64], n::Integer) where {TF<:AbstractFloat}\ncheb_lobatto_points([TF=Float64], n::Integer, lower_bound::TF, upper_bound::TF) where {TF<:AbstractFloat}\n\nGenerate Chebyshev points of the 1st kind.\n\nFor the standard interval [-1,1]:\n\nx_k = -cosleft(frackpin-1right) quad k = 01ldotsn-1\n\nFor mapped interval [lowerbound,upperbound]:\n\nx_mathrmmapped = fracx_mathrmmax + x_mathrmmin2 + fracx_mathrmmin - x_mathrmmax2x_k\n\nArguments\n\nTF: Type parameter for the grid points (e.g., Float64)\nn: Number of points\nlower_bound: (Optional) Lower bound of the mapped interval\nupper_bound: (Optional) Upper bound of the mapped interval\n\nReferences\n\nchebfun/@chebtech2/chebpts.m at master · chebfun/chebfun\n\n\n\n\n\n","category":"method"},{"location":"cheb/#Einstein.ChebyshevSuite.cheb_lobatto_quadrature_weights-Union{Tuple{TF}, Tuple{Type{TF}, Integer}} where TF<:AbstractFloat","page":"Chebyshev Suite","title":"Einstein.ChebyshevSuite.cheb_lobatto_quadrature_weights","text":"cheb_lobatto_quadrature_weights([TF=Float64], n::Integer) where {TF<:AbstractFloat}\n\nCompute quadrature weights for Chebyshev points of the 2nd kind.\n\nArguments\n\nTF: Type parameter for the weights (e.g., Float64)\nn: Number of points\n\nReferences\n\nchebfun/@chebtech2/quadwts.m at master · chebfun/chebfun\n\n\n\n\n\n","category":"method"},{"location":"cheb/#Einstein.ChebyshevSuite.cheb_lobatto_vals2coeffs_matrix-Union{Tuple{TF}, Tuple{Type{TF}, Integer}} where TF<:AbstractFloat","page":"Chebyshev Suite","title":"Einstein.ChebyshevSuite.cheb_lobatto_vals2coeffs_matrix","text":"cheb_lobatto_vals2coeffs_matrix([TF=Float64], n::Integer) where {TF<:AbstractFloat}\n\nConstruct the analysis matrix A that transforms function values at Chebyshev points of the 2nd kind to Chebyshev coefficients.\n\nArguments\n\nTF: Element type (defaults to Float64)\nn: Number of points/coefficients\n\n\n\n\n\n","category":"method"},{"location":"cheb/#Einstein.ChebyshevSuite.cheb_series_chop-Union{Tuple{AbstractVector{TFC}}, Tuple{TFC}, Tuple{TF}, Tuple{AbstractVector{TFC}, TF}} where {TF<:AbstractFloat, TFC<:Union{Complex{TF}, TF}}","page":"Chebyshev Suite","title":"Einstein.ChebyshevSuite.cheb_series_chop","text":"cheb_series_chop(coeffs::AbstractVector{TF}, tol::TF = eps(TF)) where {TF<:AbstractFloat}\n\nDetermine a suitable cutoff index for a coefficient vector using the \"standard\" chopping rule [AT15].\n\nReferences\n\nAurentz and Trefethen [AT15] Aurentz, J. L., & Trefethen, L. N. (2015). Chopping a Chebyshev series. ACM Transactions on Mathematical Software (TOMS), 41(4), 1-18.\nchebfun/standardChop.m (Implementation in Chebfun, MATLAB)\n\n\n\n\n\n","category":"method"},{"location":"cheb/#Einstein.ChebyshevSuite.cheb_series_derivative!-Union{Tuple{TFC}, Tuple{AbstractVector{TFC}, AbstractVector{TFC}}} where TFC<:Union{AbstractFloat, Complex{<:AbstractFloat}}","page":"Chebyshev Suite","title":"Einstein.ChebyshevSuite.cheb_series_derivative!","text":"cheb_series_derivative!(coeffs::AbstractVector{TFC}) where {TFC<:Union{AbstractFloat,Complex{<:AbstractFloat}}}\ncheb_series_derivative!(coeffs_der::AbstractVector{TFC}, coeffs::AbstractVector{TFC}) where {TFC<:Union{AbstractFloat,Complex{<:AbstractFloat}}}\ncheb_series_derivative(coeffs::AbstractVector{TFC}) where {TFC<:Union{AbstractFloat,Complex{<:AbstractFloat}}}\n\nCompute derivatives of coefficients of Chebyshev series.\n\nArguments\n\ncoeffs: Input vector of Chebyshev coefficients with length n\n\nReferences\n\nchebfun/@chebtech/diff.m at master · chebfun/chebfun\n\n\n\n\n\n","category":"method"},{"location":"cheb/#Einstein.ChebyshevSuite.cheb_series_evaluate-Union{Tuple{TFC}, Tuple{TF}, Tuple{AbstractVector{TFC}, TF}} where {TF<:AbstractFloat, TFC<:Union{Complex{TF}, TF}}","page":"Chebyshev Suite","title":"Einstein.ChebyshevSuite.cheb_series_evaluate","text":"cheb_series_evaluate(coeffs::AbstractVector{TFC}, x::TF) where {TF<:AbstractFloat,TFC<:Union{TF,Complex{TF}}\ncheb_series_evaluate(coeffs::AbstractVector{TFC}, x::AbstractVector{TF}) where {TF<:AbstractFloat,TFC<:Union{TF,Complex{TF}}\n\nEvaluate Chebyshev coefficients at point(s) using Clenshaw's algorithm.\n\nPerformance Notes\n\nClenshaw's algorithm: O(n) operations per point\n[TODO] NDCT: O(n log n) operations for many points simultaneously\n\nReferences\n\nchebfun/@chebtech/clenshaw.m at master · chebfun/chebfun\nchebfun/@chebtech/feval.m at master · chebfun/chebfun\n\n\n\n\n\n","category":"method"},{"location":"cheb/#Einstein.ChebyshevSuite.cheb_series_filter_weights_exp-Union{Tuple{TF}, Tuple{Type{TF}, Integer, Integer, Integer}} where TF<:AbstractFloat","page":"Chebyshev Suite","title":"Einstein.ChebyshevSuite.cheb_series_filter_weights_exp","text":"cheb_series_filter_weights_exp([TF=Float64], n::Integer, a::Integer, p::Integer) where {TF<:AbstractFloat}\n\nCompute exponential filter weights for Chebyshev series [SLS09].\n\nw_k = e^-alphaleft(k  nright)^2 p quad k = 0 ldots n-1\n\nArguments\n\nTF: Type parameter for floating-point precision\nn: Number of grid points\nα: Filter strength parameter\np: Order of filter\n\nExamples\n\nalpha = 36\nand p = 32 for weak filter [SLS09, HWB16]\nalpha = 40\nand p = 8 for strong filter [Rip23]\n\n\n\n\n\n","category":"method"},{"location":"cheb/#Einstein.ChebyshevSuite.cheb_series_integrate!-Union{Tuple{TFC}, Tuple{AbstractVector{TFC}, AbstractVector{TFC}}} where TFC<:Union{AbstractFloat, Complex{<:AbstractFloat}}","page":"Chebyshev Suite","title":"Einstein.ChebyshevSuite.cheb_series_integrate!","text":"cheb_series_integrate(df::AbstractVector{TFC}) where {TFC<:Union{AbstractFloat,Complex{<:AbstractFloat}}}\ncheb_series_integrate!(f::AbstractVector{TFC}, df::AbstractVector{TFC}) where {TFC<:Union{AbstractFloat,Complex{<:AbstractFloat}}}\n\nCompute the indefinite integral of a function f(x) given its Chebyshev series, with the constant of integration chosen such that f(-1) = 0.\n\nMathematical Details\n\nIf the input function f(x) is represented by a Chebyshev series of length n:\n\nf(x) = sum_r=0^n-1 c_r T_r(x)\n\nits integral f(x) is represented by a Chebyshev series of length n+1:\n\nf(x) = sum_r=0^n b_r T_r(x)\n\nwhere:\n\nb_0\nis determined from the constant of integration as:\n\nb_0 = sum_r=1^n (-1)^r+1 b_r\n\nThe other coefficients are given by:\n\nb_1 = c_0 - c_22\nb_r = (c_r-1 - c_r+1)(2r) text for  r  1\n\nwith c_n+1 = c_n+2 = 0.\n\nArguments\n\ndf: Vector of Chebyshev series coefficients of f\nf: Vector of Chebyshev series coefficients of f\n\nReferences\n\nchebfun/@chebtech/cumsum.m at master · chebfun/chebfun\n\n\n\n\n\n","category":"method"},{"location":"cheb/#Einstein.ChebyshevSuite.cheb_series_integration_matrix-Union{Tuple{TR}, Tuple{Type{TR}, Integer}} where TR<:AbstractFloat","page":"Chebyshev Suite","title":"Einstein.ChebyshevSuite.cheb_series_integration_matrix","text":"cheb_series_integration_matrix([TR=Float64], n::Integer) where {TR<:AbstractFloat}\ncheb_series_integration_matrix([TR=Float64], n::Integer, lower_bound::TR, upper_bound::TR) where {TR<:AbstractFloat}\n\nGenerate the Chebyshev coefficient integration matrix that maps Chebyshev coefficients to the coefficients of the integral of the interpolating polynomial.\n\nArguments\n\nTR: Type parameter for the matrix elements (e.g., Float64)\nn: Size of the matrix (n×n)\nlower_bound: (Optional) Lower bound of the integration interval\nupper_bound: (Optional) Upper bound of the integration interval\n\nReferences\n\nchebfun/@chebcolloc1/chebcolloc1.m at master · chebfun/chebfun\nchebfun/@chebcolloc2/chebcolloc2.m at master · chebfun/chebfun\n\n\n\n\n\n","category":"method"},{"location":"cheb/#Chebyshev-grids-of-first-or-second-kind","page":"Chebyshev Suite","title":"Chebyshev grids of first or second kind","text":"","category":"section"},{"location":"cheb/","page":"Chebyshev Suite","title":"Chebyshev Suite","text":"Einstein.ChebyshevSuite.ChebyshevGaussGrid\nEinstein.ChebyshevSuite.ChebyshevLobattoGrid","category":"page"},{"location":"cheb/#Einstein.ChebyshevSuite.ChebyshevGaussGrid","page":"Chebyshev Suite","title":"Einstein.ChebyshevSuite.ChebyshevGaussGrid","text":"The ChebyshevGaussGrid module provides a comprehensive set of tools for working with Chebyshev points of the 1st kind and coefficients of the corresponding 1st-kind Chebyshev series expansion.\n\nThe module is designed to work with the standard interval [-1,1] by default, but also supports mapped intervals [a,b] through appropriate scaling transformations.\n\nReferences\n\nchebfun/@chebtech1/chebtech1.m at master · chebfun/chebfun\n\n\n\n\n\n","category":"module"},{"location":"cheb/#Einstein.ChebyshevSuite.ChebyshevLobattoGrid","page":"Chebyshev Suite","title":"Einstein.ChebyshevSuite.ChebyshevLobattoGrid","text":"The ChebyshevLobattoGrid module provides a comprehensive set of tools for working with Chebyshev points of the 2nd kind and coefficients of the corresponding 1st-kind Chebyshev series expansion.\n\nThe module is designed to work with the standard interval [-1,1] by default, but also supports mapped intervals [a,b] through appropriate scaling transformations.\n\nReferences\n\nchebfun/@chebtech2/chebtech2.m at master · chebfun/chebfun\n\n\n\n\n\n","category":"module"},{"location":"qnm/#QNM-Suite","page":"QNM Suite","title":"QNM Suite","text":"","category":"section"},{"location":"qnm/","page":"QNM Suite","title":"QNM Suite","text":"Modules = [Einstein.QNMSuite]","category":"page"},{"location":"qnm/","page":"QNM Suite","title":"QNM Suite","text":"Modules = [Einstein.QNMSuite]","category":"page"},{"location":"qnm/#Einstein.QNMSuite.continued_fraction_lentz-Union{Tuple{T}, Tuple{Type{T}, Function, Function, T, Integer, Integer}} where T<:AbstractFloat","page":"QNM Suite","title":"Einstein.QNMSuite.continued_fraction_lentz","text":"continued_fraction_lentz([T=Float64], a::Function, b::Function, tol::T, min_iter::Integer, max_iter::Integer) where {T<:AbstractFloat}\n\nCompute the continued fraction\n\nf(x)=b_0+fraca_1b_1+fraca_2b_2+fraca_3b_3+fraca_4b_4+fraca_5b_5+cdots\n\nusing modified Lentz's method. Translated from duetosymmetry/qnm.\n\nArguments\n\na: A function that returns the aᵢ terms.\nb: A function that returns the bᵢ terms.\ntol: The tolerance for convergence.\nmin_iter: The minimum number of iterations to perform.\nmax_iter: The maximum number of iterations to perform.\n\nReturns\n\nfᵢ: The value of the continued fraction.\nerrorᵢ: The estimated error.\ni: The number of iterations performed.\n\nExamples\n\nCompute the square root of two using continued fractions\n\nsqrt2 = 1 + frac12 + frac12 + frac12 + frac12 + cdots approx 1414213562373095\n\na(i) = 1\nb(i) = i == 0 ? 1 : 2\ncontinued_fraction_lentz(Float64, a, b, 10*eps(Float64), 50, 1000)\n\nCompute Golden Ratio\n\nphi = 1 + frac11 + frac11 + frac11 + cdots approx 1618033988749895\n\na(i) = 1\nb(i) = 1\ncontinued_fraction_lentz(Float64, a, b, 10*eps(Float64), 50, 1000)\n\nReferences\n\nqnm/qnm/contfrac.py at master · duetosymmetry/qnm\n[Pre07, Ste19, Len76, TB86, Tem24]\n\n\n\n\n\n","category":"method"},{"location":"qnm/#Einstein.QNMSuite.qnm_kerr-Union{Tuple{TA}, Tuple{TI}, Tuple{TF}, Tuple{TF, TI, TI, TI, Complex{TF}}} where {TF<:AbstractFloat, TI<:Integer, TA<:SciMLBase.AbstractNonlinearAlgorithm}","page":"QNM Suite","title":"Einstein.QNMSuite.qnm_kerr","text":"qnm_kerr(a, s, l, m, ω_guess; kwargs...)\n\nFind the Kerr QNM using Leaver's method for the radial equation and the Cook-Zalutskiy approach for the angular sector. We use the unit M = G = c = 1.\n\nArguments\n\na: Kerr parameter (dimensionless spin parameter, 0 ≤ |a| ≤ 1)\ns: Spin weight of the field (±2 for gravitational perturbations, ±1 for electromagnetic perturbations, 0 for scalar perturbations)\nl: Angular momentum quantum number (l ≥ |s|)\nm: Azimuthal harmonic index (-l ≤ m ≤ l)\nω_guess: Initial guess for the QNM frequency\n\nKeyword Arguments\n\nn: Overtone number (default: 0 for fundamental mode)\nA_guess: Initial guess for the angular separation constant (default: nothing)\npoles: Vector of known poles to subtract from the continued fraction (default: empty)\nl_max: Maximum angular momentum for angular eigenvalue calculation (default: l + 20)\ncf_n_inv: Number of inverse terms in the continued fraction (default: 0)\ncf_N_min: Minimum number of terms in the continued fraction (default: 300)\ncf_N_max: Maximum number of terms in the continued fraction (default: 100000)\ncf_tol: Tolerance for continued fraction convergence (default: machine epsilon)\nnonlinear_algorithm: Algorithm for solving the nonlinear eigenvalue problem (default: RobustMultiNewton with AutoFiniteDiff)\nangular_matrix_cache: Pre-allocated matrix for angular eigenvalue calculation (default: nothing)\nkwargs...: Additional keyword arguments passed to the nonlinear solver\n\nReturns\n\nComplex{TF}: The complex QNM frequency omega\n\nExamples\n\na = 0.7\ns = 2\nl = 2\nm = 2\nn = 0\nω = 0.532600243551018 - 0.08079287315500766im\nl_max = 20\n\nω_pert = ω + rand(Complex{Float64}) / 1000\n\nωsol = qnm_kerr(a, s, l, m, ω_pert; n=n, l_max=l_max)\n\nNotes\n\nThe function uses a combination of Leaver's method for the radial equation and the Cook-Zalutskiy approach for the angular sector\nThe continued fraction method is used to solve the radial equation\nThe angular eigenvalue problem is solved using matrix eigenvalue methods\nThe function returns the complex frequency where the imaginary part is negative (damped modes)\n\n\n\n\n\n","category":"method"},{"location":"qnm/#Einstein.QNMSuite.qnm_kerr_radial-Union{Tuple{TI}, Tuple{TR}, Tuple{QNMKerrContext{TR, TI}, Complex{TR}, Complex{TR}}} where {TR<:AbstractFloat, TI<:Integer}","page":"QNM Suite","title":"Einstein.QNMSuite.qnm_kerr_radial","text":"qnm_kerr_radial(ctx::QNMKerrContext{TR,TI}, A::Complex{TR}, ω::Complex{TR}) where {TR<:AbstractFloat,TI<:Integer}\n\nCalculate the radial function using the Leaver scheme [CZ14].\n\nArguments\n\nctx: QNMKerrContext object.\nA::Complex{TR}: Angular separation constant.\nω::Complex{TR}: QNM frequency.\n\nReturns\n\ninv_cf::Complex{TR}: The inverse continued fraction.\nerror::TR: The error.\niter::Integer: The number of iterations.\n\nLeaver scheme\n\nbeginaligned\n D_0=delta=1+s+2 xi \n D_1=4 p-2 alpha+gamma-delta-2 \n D_2=2 alpha-gamma+2 \n D_3=alpha(4 p-delta)-sigma \n D_4=alpha(alpha-gamma+1)\nendaligned\n\nbeginaligned\nalpha_n  equiv n^2+left(D_0+1right) n+D_0 \nbeta_n  equiv-2 n^2+left(D_1+2right) n+D_3 \ngamma_n  equiv n^2+left(D_2-3right) n+D_4-D_2+2\nendaligned\n\nThe general continued fraction:\n\n0=beta_0-fracalpha_0 gamma_1beta_1- fracalpha_1 gamma_2beta_2- fracalpha_2 gamma_3beta_3- ldots\n\nThe truncated version of the continued fraction:\n\noperatornameCf(mathrmN) equiv beta_0-fracalpha_0 gamma_1beta_1- fracalpha_1 gamma_2beta_2- fracalpha_2 gamma_3beta_3- ldots fracalpha_mathrmN-1 gamma_mathrmNbeta_mathrmN+alpha_mathrmN mathrmr_mathrmN\n\nThe nth inversion of this truncated continued fraction:\n\nbeginaligned\noperatornameCf(mathrmn  mathrmN) equiv  beta_n-fracalpha_n-1 gamma_nbeta_n-1- fracalpha_n-2 gamma_n-1beta_n-2- ldots fracalpha_0 gamma_1beta_0 \n -fracalpha_n gamma_n+1beta_n+1- fracalpha_n+1 gamma_n+2beta_n+2- cdots fracalpha_N-1 gamma_Nbeta_N+alpha_N r_N\nendaligned\n\nwith operatornameCf(0  mathrmN) equiv operatornameCf(mathrmN) and 0 leq n  N\n\nReferences\n\nCook and Zalutskiy [CZ14]\nqnm/qnm/radial.py at master · duetosymmetry/qnm\n\n\n\n\n\n","category":"method"},{"location":"qnm/#Einstein.QNMSuite.qnm_pep_companion-Union{Tuple{AbstractVector{<:AbstractMatrix{TN}}}, Tuple{TN}} where TN<:Number","page":"QNM Suite","title":"Einstein.QNMSuite.qnm_pep_companion","text":"A, E = qnm_pep_companion(TFC, pep::AbstractVector{<:AbstractMatrix}) where TFC <: Union{AbstractFloat, Complex{<:AbstractFloat}}\n\nLinearizes a polynomial eigenvalue problem (PEP) and returns the companion form, as in the paper by Mehrmann and Voss. More precisely, for a k-th degree PEP with n-by-n coefficient matrices, this returns matrices A and E, both kn-by-kn, corresponding to the linearized problem\n\nAx = λEx\n\nReferences\n\nMehrmann and Voss [MV04]\nNonlinearEigenproblems.jl/src/method_companion.jl at master · nep-pack/NonlinearEigenproblems.jl\n\n\n\n\n\n","category":"method"},{"location":"qnm/#Einstein.QNMSuite.qnm_schw_reggepoleexp-Union{Tuple{TR}, Tuple{Type{TR}, Integer, Integer, Integer}} where TR<:AbstractFloat","page":"QNM Suite","title":"Einstein.QNMSuite.qnm_schw_reggepoleexp","text":"qnm_schw_reggepoleexp(::Type{TR}, s::TI, l::TI, n::TI) where {TR<:AbstractFloat,TI<:Integer}\n\nCompute the high ell asymptotic expansion of Schwarzschild QNM frequency, using the method of Dolan and Ottewill [DO09].\n\nThe QNM frequency can be written as an expansion in inverse powers of L=ell+frac12\n\nomega_l n=varpi_-1^(n) L+varpi_0^(n)+varpi_1^(n) L^-1+varpi_2^(n) L^-2+ldots\n\nThe lowest expansion coefficients for arbitrary spin beta=1-s^2 and arbitrary overtone number n are given by\n\nbeginaligned\n sqrt27 varpi_-1^(n)=1 \n sqrt27 varpi_0^(n)=-i N \n sqrt27 varpi_1^(n)=fracbeta3-frac5 N^236-frac115432 \n sqrt27 varpi_2^(n)=-i Nleftfracbeta9+frac235 N^23888-frac141515552right \n sqrt27 varpi_3^(n)=-fracbeta^227+frac204 N^2+2113888 beta+frac854160 N^4-1664760 N^2-77693940310784 \n sqrt27 varpi_4^(n)=i Nleftfracbeta^227+frac1100 N^2-271946656 beta+frac11273136 N^4-52753800 N^2+664805352902376448right\nendaligned\n\nArguments\n\nTR: Type of the floating-point number.\ns: Spin weight of the field of interest.\nl: Multipole number of interest.\nn: Overtone number of interest.\n\nReferences\n\n[DO09]\n\n\n\n\n\n","category":"method"},{"location":"fdm/#Finite-Difference-Suite","page":"Finite Difference Suite","title":"Finite Difference Suite","text":"","category":"section"},{"location":"fdm/","page":"Finite Difference Suite","title":"Finite Difference Suite","text":"Modules = [Einstein.FiniteDifferenceSuite]","category":"page"},{"location":"fdm/","page":"Finite Difference Suite","title":"Finite Difference Suite","text":"Modules = [Einstein.FiniteDifferenceSuite]","category":"page"},{"location":"fdm/#Einstein.FiniteDifferenceSuite.LocalBarycentricInterpolation","page":"Finite Difference Suite","title":"Einstein.FiniteDifferenceSuite.LocalBarycentricInterpolation","text":"LocalBarycentricInterpolation(points, values; degree=4)\n\nConstruct a local barycentric Lagrange interpolant for equispaced data points.\n\nCreates a polynomial approximation of degree degree using the data values at uniformly  spaced points points. The interpolation is performed locally using degree + 1 points  nearest to the evaluation point.\n\nArguments\n\npoints::StepRangeLen{TF}: Equispaced points for interpolation\nvalues::AbstractVector{TF}: Function values at the points\ndegree::Integer=4: Degree of the local polynomial interpolant\n\nReturns\n\nAn interpolant function that can be evaluated at any point within [minimum(points), maximum(points)]\n\nNotes\n\nRequires length(points) >= degree + 1\npoints and values must have the same length\nUses barycentric Lagrange interpolation for numerical stability\n\nReferences\n\nBerrut and Trefethen [BT04b]\n\n\n\n\n\n","category":"type"},{"location":"fdm/#Einstein.FiniteDifferenceSuite.fdm_boundary_weights-Union{Tuple{TR}, Tuple{Type{TR}, Integer, Integer}} where TR<:Real","page":"Finite Difference Suite","title":"Einstein.FiniteDifferenceSuite.fdm_boundary_weights","text":"fdm_boundary_weights([TR=Rational{TI}], derivative_order::TI, accuracy_order::TI) where {TR<:Real, TI<:Integer}\n\nGenerate finite difference coefficients for shifted boundary conditions.\n\nArguments\n\nderivative_order::Integer: The order of the derivative to approximate\naccuracy_order::Integer: The desired order of accuracy\n\nReturns\n\nTuple of left and right shifted boundary finite difference coefficients The coefficients are stored in a matrix with the rows representing the different grid points. The rows are ordered from the leftmost grid point to the rightmost grid point.\n\n\n\n\n\n","category":"method"},{"location":"fdm/#Einstein.FiniteDifferenceSuite.fdm_boundary_width-Tuple{Integer, Integer}","page":"Finite Difference Suite","title":"Einstein.FiniteDifferenceSuite.fdm_boundary_width","text":"fdm_boundary_width(derivative_order::Integer, accuracy_order::Integer)\n\nCalculate the number of coefficients needed for shifted boundary FDM stencil.\n\n\n\n\n\n","category":"method"},{"location":"fdm/#Einstein.FiniteDifferenceSuite.fdm_central_weights-Union{Tuple{TR}, Tuple{Type{TR}, Integer, Integer}} where TR<:Real","page":"Finite Difference Suite","title":"Einstein.FiniteDifferenceSuite.fdm_central_weights","text":"fdm_central_weights([TR=Rational{TI}], derivative_order::TI, accuracy_order::TI) where {TR<:Real, TI<:Integer}\n\nGenerate central finite difference coefficients for a given derivative and accuracy order.\n\nArguments\n\nderivative_order::Integer: The order of the derivative to approximate\naccuracy_order::Integer: The desired order of accuracy (must be even)\n\nReturns\n\nVector of rational coefficients for the finite difference stencil\n\n\n\n\n\n","category":"method"},{"location":"fdm/#Einstein.FiniteDifferenceSuite.fdm_central_width-Tuple{Integer, Integer}","page":"Finite Difference Suite","title":"Einstein.FiniteDifferenceSuite.fdm_central_width","text":"fdm_central_width(derivative_order::Integer, accuracy_order::Integer)\n\nCalculate the number of coefficients needed for central FDM stencil.\n\nReferences\n\nFinite difference coefficient - Wikipedia\n\n\n\n\n\n","category":"method"},{"location":"fdm/#Einstein.FiniteDifferenceSuite.fdm_derivative_operator-Union{Tuple{TI}, Tuple{TR}, Tuple{Type{TR}, TI, TI, TR}} where {TR<:Real, TI<:Integer}","page":"Finite Difference Suite","title":"Einstein.FiniteDifferenceSuite.fdm_derivative_operator","text":"fdm_derivative_operator([TR=Float64], derivative_order::Integer, accuracy_order::Integer, dx::TR) -> FiniteDifferenceDerivativeOperator{TR}\n\nCreate a finite difference derivative operator with specified derivative and accuracy orders.\n\nArguments\n\nTR: The element type of the operator\nderivative_order::Integer: The order of the derivative\naccuracy_order::Integer: The order of accuracy\ndx::TR: The grid spacing\n\n\n\n\n\n","category":"method"},{"location":"fdm/#Einstein.FiniteDifferenceSuite.fdm_dissipation_boundary_weights-Union{Tuple{TR}, Tuple{Type{TR}, Integer}} where TR<:Real","page":"Finite Difference Suite","title":"Einstein.FiniteDifferenceSuite.fdm_dissipation_boundary_weights","text":"fdm_dissipation_boundary_weights([TR=Rational{Int}], dissipation_order::Integer)\n\nCalculate the weights for Kreiss-Oliger dissipation of given order at the boundary [B+08].\n\n\n\n\n\n","category":"method"},{"location":"fdm/#Einstein.FiniteDifferenceSuite.fdm_dissipation_boundary_width-Tuple{Integer}","page":"Finite Difference Suite","title":"Einstein.FiniteDifferenceSuite.fdm_dissipation_boundary_width","text":"fdm_dissipation_boundary_width(dissipation_order::Integer)\n\nCalculate the number of coefficients needed for Kreiss-Oliger dissipation (boundary).\n\n\n\n\n\n","category":"method"},{"location":"fdm/#Einstein.FiniteDifferenceSuite.fdm_dissipation_operator-Union{Tuple{TI}, Tuple{TR}, Tuple{Type{TR}, TI, TR, TR}} where {TR<:Real, TI<:Integer}","page":"Finite Difference Suite","title":"Einstein.FiniteDifferenceSuite.fdm_dissipation_operator","text":"fdm_dissipation_operator([TR=Float64], dissipation_order::TI, σ::TR, dx::TR) -> FiniteDifferenceDerivativeOperator{TR}\n\nCreate a finite difference dissipation operator with specified dissipation order.\n\nArguments\n\nTR: The element type of the operator\ndissipation_order::Integer: The order of the dissipation operator\nσ::TR: The dissipation coefficient\ndx::TR: The grid spacing\n\n\n\n\n\n","category":"method"},{"location":"fdm/#Einstein.FiniteDifferenceSuite.fdm_dissipation_order-Tuple{Integer}","page":"Finite Difference Suite","title":"Einstein.FiniteDifferenceSuite.fdm_dissipation_order","text":"fdm_dissipation_order(accuracy_order::Integer)\n\nCalculate the order of dissipation needed for a given finite difference accuracy order [B+08]. For a scheme of accuracy order 2r-2, returns dissipation order 2r.\n\n\n\n\n\n","category":"method"},{"location":"fdm/#Einstein.FiniteDifferenceSuite.fdm_dissipation_weights-Union{Tuple{TR}, Tuple{Type{TR}, Integer}} where TR<:Real","page":"Finite Difference Suite","title":"Einstein.FiniteDifferenceSuite.fdm_dissipation_weights","text":"fdm_dissipation_weights([TR=Rational{Int}], dissipation_order::Integer)\n\nCalculate the weights for Kreiss-Oliger dissipation of given order [B+08].\n\n\n\n\n\n","category":"method"},{"location":"fdm/#Einstein.FiniteDifferenceSuite.fdm_dissipation_width-Tuple{Integer}","page":"Finite Difference Suite","title":"Einstein.FiniteDifferenceSuite.fdm_dissipation_width","text":"fdm_dissipation_width(dissipation_order::Integer)\n\nCalculate the number of coefficients needed for Kreiss-Oliger dissipation (interior).\n\n\n\n\n\n","category":"method"},{"location":"fdm/#Einstein.FiniteDifferenceSuite.fdm_extrapolation_weights-Tuple{Int64, Symbol}","page":"Finite Difference Suite","title":"Einstein.FiniteDifferenceSuite.fdm_extrapolation_weights","text":"fdm_extrapolation_weights(extrapolation_order::Int, direction::Symbol)\n\nGenerate weights for left or right extrapolation.\n\nArguments\n\nextrapolation_order::Int: Order of extrapolation\ndirection::Symbol: Direction of extrapolation (:left or :right)\n\nReturns\n\nVector of Integer coefficients for the extrapolation weights.\n\n\n\n\n\n","category":"method"},{"location":"fdm/#Einstein.FiniteDifferenceSuite.fdm_hermite_boundary_weights-Union{Tuple{TR}, Tuple{Type{TR}, Integer, Integer}} where TR<:Real","page":"Finite Difference Suite","title":"Einstein.FiniteDifferenceSuite.fdm_hermite_boundary_weights","text":"fdm_hermite_boundary_weights([TR=Rational{TI}], derivative_order::TI, accuracy_order::TI) where {TR<:Real, TI<:Integer}\n\nGenerate Hermite-type finite difference coefficients for boundary conditions.\n\n\n\n\n\n","category":"method"},{"location":"fdm/#Einstein.FiniteDifferenceSuite.fdm_hermite_boundary_width-Tuple{Integer, Integer}","page":"Finite Difference Suite","title":"Einstein.FiniteDifferenceSuite.fdm_hermite_boundary_width","text":"fdm_hermite_boundary_width(derivative_order::Integer, accuracy_order::Integer)\n\nCalculate the number of coefficients needed for Hermite FDM stencil on boundary.\n\n\n\n\n\n","category":"method"},{"location":"fdm/#Einstein.FiniteDifferenceSuite.fdm_hermite_weights-Union{Tuple{TR}, Tuple{Type{TR}, Integer, Integer}} where TR<:Real","page":"Finite Difference Suite","title":"Einstein.FiniteDifferenceSuite.fdm_hermite_weights","text":"fdm_hermite_weights([TR=Rational{TI}], derivative_order::TI, accuracy_order::TI) where {TR<:Real, TI<:Integer}\n\nGenerate Hermite-type finite difference coefficients that include function value and derivative information.\n\nArguments\n\nderivative_order::Integer: The order of the derivative to approximate (must be ≥ 2)\naccuracy_order::Integer: The desired order of accuracy\nFor derivativeorder 2,3,6,7,10,11...: accuracyorder must be 4,8,12...\nFor derivativeorder 4,5,8,9,12...: accuracyorder must be 2,6,10...\n\nReturns\n\nVector of rational coefficients for the Hermite-type finite difference stencil\n\n\n\n\n\n","category":"method"},{"location":"fdm/#Einstein.FiniteDifferenceSuite.fdm_hermite_width-Tuple{Integer, Integer}","page":"Finite Difference Suite","title":"Einstein.FiniteDifferenceSuite.fdm_hermite_width","text":"fdm_hermite_width(derivative_order::Integer, accuracy_order::Integer)\n\nCalculate the number of coefficients needed for Hermite FDM stencil.\n\nReferences\n\nFornberg [For21]\n\n\n\n\n\n","category":"method"},{"location":"fdm/#Einstein.FiniteDifferenceSuite.fdm_integrate_simpson-Union{Tuple{T}, Tuple{AbstractVector{T}, T}} where T<:AbstractFloat","page":"Finite Difference Suite","title":"Einstein.FiniteDifferenceSuite.fdm_integrate_simpson","text":"fdm_integrate_simpson(f::AbstractVector{T}, dx::T) where {T<:AbstractFloat}\n\nIntegrate a function f using Simpson's rule, given the grid spacing dx.\n\n\n\n\n\n","category":"method"},{"location":"fdm/#Einstein.FiniteDifferenceSuite.fdm_operator_matrix-Union{Tuple{TR}, Tuple{Einstein.FiniteDifferenceSuite.AbstractFiniteDifferenceOperator{TR}, Integer}, Tuple{Einstein.FiniteDifferenceSuite.AbstractFiniteDifferenceOperator{TR}, Integer, Bool}, Tuple{Einstein.FiniteDifferenceSuite.AbstractFiniteDifferenceOperator{TR}, Integer, Bool, Bool}} where TR<:Real","page":"Finite Difference Suite","title":"Einstein.FiniteDifferenceSuite.fdm_operator_matrix","text":"fdm_operator_matrix(op::AbstractFiniteDifferenceOperator{TR}; boundary::Bool=false, transpose::Bool=false) -> BandedMatrix{TR}\n\nCreate a banded matrix representation of the finite difference operator.\n\nArguments\n\nop::AbstractFiniteDifferenceOperator{TR}: The finite difference operator\nboundary::Bool=true: Whether to include boundary weights\ntranspose::Bool=false: Whether to transpose the matrix\n\n\n\n\n\n","category":"method"},{"location":"fdm/#Einstein.FiniteDifferenceSuite.fdm_weights_fornberg-Union{Tuple{TR}, Tuple{Integer, TR, AbstractVector{TR}}} where TR<:Real","page":"Finite Difference Suite","title":"Einstein.FiniteDifferenceSuite.fdm_weights_fornberg","text":"fdm_weights_fornberg([TR=Float64], order::Integer, x0::Real, x::AbstractVector; \n                         hermite::Bool=false)\n\nCalculate finite difference weights for arbitrary-order derivatives using the Fornberg algorithm. Taken from SciML/MethodOfLines.jl.\n\nArguments\n\nTR: Type parameter for the weights (defaults to type of x0)\norder: Order of the derivative to approximate\nx0: Point at which to approximate the derivative\nx: Grid points to use in the approximation\nhermite: Whether to include first derivative values (Hermite finite differences)\n\nReturns\n\nIf hermite == false:\n\nVector{TR}: Weights for standard finite differences\n\nIf hermite == true:\n\nTuple{Vector{TR}, Vector{TR}}: Weights for Hermite finite differences\n\nRequirements\n\nFor standard finite differences: N > order\nFor Hermite finite differences: N > order/2 + 1\n\nwhere N is the length of x\n\nExamples\n\n# Standard central difference for first derivative\nx = [-1.0, 0.0, 1.0]\nw = fdm_weights_fornberg(1, 0.0, x)\n# Returns approximately [-0.5, 0.0, 0.5]\n\n# Forward difference for second derivative\nx = [0.0, 1.0, 2.0, 3.0]\nw = fdm_weights_fornberg(2, 0.0, x)\n\n# Hermite finite difference for third derivative\nx = [-1.0, 0.0, 1.0]\nw_f, w_d = fdm_weights_fornberg(3, 0.0, x, hermite=true)\n\nReferences\n\nMethodOfLines.jl/src/discretization/schemes/fornbergcalculateweights.jl at master · SciML/MethodOfLines.jl\nFornberg [For88]\nFornberg [For21]\nFornberg [For98]\nprecision - Numerical derivative and finite difference coefficients: any update of the Fornberg method? - Computational Science Stack Exchange\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Einstein","category":"page"},{"location":"#Einstein","page":"Home","title":"Einstein","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for Einstein.","category":"page"},{"location":"","page":"Home","title":"Home","text":"warning: Warning\nI'm still actively developing it and migrating code from private repositories to this one, so it may currently lack some features.","category":"page"},{"location":"#Motivation-and-Purpose","page":"Home","title":"Motivation and Purpose","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"After developing hundreds of PDE solvers for various projects, I decided to create Einstein.jl because I couldn't find a library that was both highly convenient and effective for solving partial differential equations (PDEs) in the context of general relativity (GR).","category":"page"},{"location":"","page":"Home","title":"Home","text":"When solving GR PDEs in spherical symmetry or even axisymmetry, the requirements are often far more demanding than in 3+1 cases. These include the need for very long-time simulations, conservation of quantities, highly accurate late-time behavior, and precise computation of quasinormal modes. While I have addressed these challenges individually in the past, I grew tired of copying and pasting solutions from old repositories. Instead, I decided to develop a comprehensive, feature-rich, and highly efficient library. This is my answer to those challenges.","category":"page"},{"location":"#Description","page":"Home","title":"Description","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Einstein.jl is a high-performance suite designed to compute arbitrary-precision solutions of PDEs in GR. It is planned to support solving the following built-in equations (some of which were developed for previous projects and will be ported to this library):","category":"page"},{"location":"","page":"Home","title":"Home","text":"Spatial Discretization\n[x] Chebyshev collocation at Chebyshev points of the first and second kinds (Most of algorithms are translated from Chebfun)\n[x] Finite difference method\n[x] Hermite finite difference method\n[x] Rectangular collocation method (Most of algorithms are translated from Chebfun)\n[x] Ultraspherical spectral method (Most of algorithms are translated from Chebfun)\nFor boundary value problems, I recommend using ApproxFun.jl.\n[ ] Ultraspherical rectangular collocation\nGeneral Utilities\n[x] Correctly rounded floating-point dot/sum using xsum or Kahan summation\n[x] Spin-weighted spheroidal harmonics using the Cook-Zalutskiy spectral method\nQuasinormal Modes\n[ ] Compute quasinormal modes for the Schwarzschild black hole using the Regge-Wheeler-Zerilli equation.\n[ ] Continued fraction method to determine the eigenvalue\n[x] Ultraspherical spectral method in hyperboloidal coordinates to determine the eigenfunction.\n[x] Dolan and Ottewill Regge poles expansion method\n[ ] WKB approximation\n[ ] Direct integration method\n[x] Compute quasinormal modes for the Kerr black hole using the Teukolsky equation.\n[x] Continued fraction method for the radial equation (translated from duetosymmetry/qnm)\n[x] Cook-Zalutskiy spectral method for the angular sector (translated from duetosymmetry/qnm)\n[x] Direct integration method for the radial equation\n[x] Ultraspherical spectral method in hyperboloidal coordinates to determine the eigenfunction.\nUtilities\n[x] Modified Lentz method for continued fractions\n[ ] WKB approximation for general potentials\nTime Domain\nSpherical Symmetry\n[ ] Regge-Wheeler-Zerilli equation\n[ ] Hyperboloidal coordinates\n[ ] Kerr-Schild coordinates\n[ ] Tortoise coordinates\n[ ] Klein-Gordon equation\n[ ] Hyperboloidal coordinates\n[ ] Kerr-Schild coordinates\n[ ] Tortoise coordinates\n[ ] Einstein equations with a scalar field\n[ ] Z4 formulation\n[ ] Hyperboloidal coordinates\nAxisymmetry\n[ ] Teukolsky equation\n[ ] Hyperboloidal coordinates\n[ ] Kerr-Schild coordinates\n[ ] Tortoise coordinates\n[ ] Klein-Gordon equation\n[ ] Hyperboloidal coordinates\n[ ] Kerr-Schild coordinates\n[ ] Tortoise coordinates","category":"page"},{"location":"","page":"Home","title":"Home","text":"While the ChebyshevSuite is inspired by algorithms from Chebfun, it has been significantly enhanced in this package to improve performance and support arbitrary-precision calculations.","category":"page"},{"location":"#Acknowledgments","page":"Home","title":"Acknowledgments","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package is inspired by the following projects, and some of the algorithms are translated / adapted from them:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Chebfun\nJuliaApproximation/ApproxFun.jl\nduetosymmetry/qnm\nSciML/MethodOfLines.jl\nNeal/xsum\nJuliaMath/KahanSummation.jl\ntomtrogdon/URCMethod.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"The author would like to thank the developers of these projects for their contributions to the scientific computing community.","category":"page"},{"location":"#Other-Related-Projects","page":"Home","title":"Other Related Projects","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"lucass-carneiro/QuasinormalModes.jl: A Julia package for computing discrete eigenvalues of second-order ODEs: This package focuses on computing quasinormal modes using the Asymptotic Iteration Method. However, as far as I know, no one has proven that the Asymptotic Iteration Method is guaranteed to converge. So why not use more reliable methods? In any case, it is good to have one more method to compare against.\nJLRipley314/TeukolskyQNMFunctions.jl: Computes quasinormal modes and eigenfunctions of the Teukolsky equation in HPHC coordinates.: Justin Ripley has developed a package that computes the quasinormal modes of the Teukolsky equation based on his own paper. We also follow his paper for the Teukolsky equation in hyperboloidal coordinates.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [Einstein]","category":"page"},{"location":"utils/#General-Utilities","page":"Utilities","title":"General Utilities","text":"","category":"section"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"Modules = [Einstein.Utils]","category":"page"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"Modules = [Einstein.Utils]","category":"page"},{"location":"utils/#Einstein.Utils.BarycentricInterpolation","page":"Utilities","title":"Einstein.Utils.BarycentricInterpolation","text":"BarycentricInterpolation{TF<:AbstractFloat}(points::AbstractVector{TF}, weights::AbstractVector{TF})\n\nA structure representing barycentric interpolation with precomputed weights.\n\nFields\n\npoints::AbstractVector{TF}: Vector of interpolation points (typically Chebyshev points)\nweights::AbstractVector{TF}: Vector of barycentric weights\n\nMethods\n\n(itp::BarycentricInterpolation{TF})(values::AbstractVector{TFC}, x::TF) where {TF<:AbstractFloat,TFC<:Union{TF,Complex{TF}}}\n\nEvaluate the interpolant at point x for function values.\n\nReference\n\nchebfun/@chebtech2/bary.m at master · chebfun/chebfun\nBerrut and Trefethen [BT04b]\n\n\n\n\n\n","category":"type"},{"location":"utils/#Einstein.Utils.SWSFun","page":"Utilities","title":"Einstein.Utils.SWSFun","text":"SWSFun{TR<:AbstractFloat}()\n(swsf::SWSFun{TR})(θ::TR)\ncoefficients(swsf::SWSFun)\n\nSpherical-weighted spheroidal harmonics. The eigenvectors contain the C coefficients in the equation:\n\n_s S_ell m(x c)=sum_ell^prime=ell_min ^infty C_ell^prime ell m(c) _s S_ell^prime m(x 0)\n\nwhere C is normalized by\n\nsum_ell^prime=ell_text min ^ell_max leftC_ell^prime ell m(c)right^2=1\n\nand the phase is chosen such that C_ell^prime ell m(c) is real for ell^prime=ell [CZ14]. The spin-weighted spheroidal harmonics are normalized such that\n\nint_0^pi _s S_ell m(x c) _s S^*_ell m(x c) sin(theta) dtheta = 1\n\nArguments\n\ns::Integer: spin\nc::Complex{TR}: oblateness parameter\nm::Integer: azimuthal number\nl::Integer: angular number\nl_max::Integer: maximum angular number\n\n\n\n\n\n","category":"type"},{"location":"utils/#Einstein.Utils.barycentric_differentiation_matrix-Union{Tuple{TF}, Tuple{AbstractVector{TF}, AbstractVector{TF}}, Tuple{AbstractVector{TF}, AbstractVector{TF}, Integer}, Tuple{AbstractVector{TF}, AbstractVector{TF}, Integer, Union{Nothing, AbstractVector{TF}}}} where TF<:AbstractFloat","page":"Utilities","title":"Einstein.Utils.barycentric_differentiation_matrix","text":"barycentric_differentiation_matrix(x::AbstractVector{TF}, w::AbstractVector{TF}, k::Integer=1, t::Union{AbstractVector{TF},Nothing}=nothing) where {TF<:AbstractFloat}\n\nCompute the barycentric differentiation matrix.\n\nArguments\n\nx::AbstractVector{TF} : Vector of interpolation points\nw::AbstractVector{TF} : Barycentric weights of the interpolation points\nk::Integer : Order of the derivative (default: 1)\nt::AbstractVector{TF} : Vector of angles (default: nothing)\n\nReferences:\n\nchebfun/@chebcolloc/baryDiffMat.m at master · chebfun/chebfun\nBaltensperger and Trummer [BT03]\n\n\n\n\n\n","category":"method"},{"location":"utils/#Einstein.Utils.barycentric_interpolate-Union{Tuple{TFC}, Tuple{TF}, Tuple{TF, AbstractVector{TF}, AbstractVector{TFC}, Vector{TF}}} where {TF<:AbstractFloat, TFC<:Union{Complex{TF}, TF}}","page":"Utilities","title":"Einstein.Utils.barycentric_interpolate","text":"barycentric_interpolate(x::TF, points::AbstractVector{TF}, values::AbstractVector{TFC}, weights::Vector{TF}) where {TF<:AbstractFloat,TFC<:Union{TF,Complex{TF}}\n\nEvaluate the value of the barycentric interpolation formula with nodes points, function values values and barycentric weights weights at point x.\n\nReferences\n\nchebfun/@chebtech2/bary.m at master · chebfun/chebfun\nBerrut and Trefethen [BT04b]\n\n\n\n\n\n","category":"method"},{"location":"utils/#Einstein.Utils.barycentric_weights-Union{Tuple{AbstractVector{TF}}, Tuple{TF}} where TF<:AbstractFloat","page":"Utilities","title":"Einstein.Utils.barycentric_weights","text":"barycentric_weights(x::AbstractVector{TF}) where {TF<:AbstractFloat}\nbarycentric_weights(x::AbstractRange{TF}) where {TF<:AbstractFloat}\nbarycentric_weights([TF=Float64], order::Integer) where {TF<:AbstractFloat}\n\nCompute normalized barycentric weights for interpolation nodes. These weights are used in barycentric Lagrange interpolation. For Chebyshev-Gauss nodes or Chebyshev-Lobatto nodes, chebgaussbarycentric_weights and cheblobattobarycentric_weights are more efficient implementations.\n\nArguments\n\nx::AbstractVector{TF}: Vector of distinct interpolation nodes, for equidistant nodes, use range is recommended x = x_min:dx:x_max\norder::Integer: order of the interpolation (order = length(x) - 1)\n\nReturns\n\nVector{TF}: Barycentric weights scaled such that their infinity norm equals 1\n\nDetails\n\nThe barycentric weights w_j for nodes x_j are computed as:\n\nw_j = frac1prod_k neq j (x_j - x_k)\n\nFor equidistant nodes, a more efficient formula is used based on binomial coefficients.\n\nExamples\n\n# For arbitrary nodes\nx = [0.0, 1.0, 2.0]\nw = barycentric_weights(x)\n\n# For equidistant nodes\nw = barycentric_weights(2)  # 3 nodes: 0, 1, 2\n\n# or\nx = 0.0:0.1:1.0\nw = barycentric_weights(x)\n\nNotes\n\nThe weights are scaled to have unit infinity norm for numerical stability\nReturns NaN weights if input points are not distinct\nlog-sum-exp trick is used to prevent underflow/overflow\nFor equidistant nodes, a more efficient algorithm based on binomial coefficients is used\n\nReferences\n\nBerrut and Trefethen [BT04b]\nchebfun/baryWeights.m at master · chebfun/chebfun\n\n\n\n\n\n","category":"method"},{"location":"utils/#Einstein.Utils.dot_kahan-Union{Tuple{T}, Tuple{StridedVector{T}, StridedVector{T}}} where T<:Number","page":"Utilities","title":"Einstein.Utils.dot_kahan","text":"dot_kahan(v1::StridedVector{T}, v2::StridedVector{T}) where {T<:Number}\n\nNeumaier's variant of Kahan summation algorithm to reduce numerical errors.\n\nNote\n\nSlower than dot_xsum for large vectors, but faster for small vectors.\nSimilar performance to dot_kahan\nUses loop unrolling for better performance while maintaining Kahan summation's\n\nnumerical stability. Processes two elements per iteration when possible.\n\nReferences\n\nJuliaMath/KahanSummation.jl\n\n\n\n\n\n","category":"method"},{"location":"utils/#Einstein.Utils.dot_xsum-Tuple{StridedVector{Float64}, StridedVector{Float64}}","page":"Utilities","title":"Einstein.Utils.dot_xsum","text":"dot_xsum(x::StridedVector{T}, y::StridedVector{T}) where {T<:Real}\n\nCompute the dot product of two vectors using extended precision accumulation. Uses the xsum package for improved numerical accuracy.\n\nNote\n\nVery fast for large vectors, but a bit slower than Kahan summation for small vectors.\nBoth input vectors must have the same length, which is not checked for performance reasons.\n\nReferences\n\nNeal [Nea15]\nJuliaMath/Xsum.jl\nRadford Neal / xsum · GitLab\n\n\n\n\n\n","category":"method"},{"location":"utils/#Einstein.Utils.sum_kahan-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T<:Number","page":"Utilities","title":"Einstein.Utils.sum_kahan","text":"sum_kahan(v::AbstractVector{T}) where {T<:Number}\n\nNeumaier's variant of Kahan summation algorithm to reduce numerical errors.\n\nNote\n\nSlower than sum_xsum for large vectors, but faster for small vectors.\nUses loop unrolling for better performance while maintaining Kahan summation's\n\nnumerical stability. Processes two elements per iteration when possible.\n\nReferences\n\nJuliaMath/KahanSummation.jl\n\n\n\n\n\n","category":"method"},{"location":"utils/#Einstein.Utils.sum_xsum-Tuple{AbstractVector{Float64}}","page":"Utilities","title":"Einstein.Utils.sum_xsum","text":"sum_xsum(vec::AbstractVector{Float64})\n\nCompute the sum of a vector using extended precision accumulation. Uses the xsum package for improved numerical accuracy.\n\nNote\n\nVery fast for large vectors, but a bit slower than Kahan summation for small vectors (n ⪅ 80)\n\nReferences\n\nNeal [Nea15]\nJuliaMath/Xsum.jl\nRadford Neal / xsum · GitLab\n\n\n\n\n\n","category":"method"},{"location":"utils/#Einstein.Utils.sws_A0-Tuple{Integer, Integer}","page":"Utilities","title":"Einstein.Utils.sws_A0","text":"sws_A0(s::Integer, l::Integer) where {TR<:AbstractFloat}\n\nCalculate angular separation constant at a = 0.\n\n_s A_ell m(0)=l(l+1)-s(s+1)\n\nArguments\n\ns::Integer: spin\nl::Integer: angular number\n\n\n\n\n\n","category":"method"},{"location":"utils/#Einstein.Utils.sws_eigM-Union{Tuple{TR}, Tuple{Type{TR}, Integer, Complex{TR}, Integer, Integer}} where TR<:AbstractFloat","page":"Utilities","title":"Einstein.Utils.sws_eigM","text":"sws_eigM(::Type{TR}, s::Integer, c::Complex{TR}, m::Integer, l_max::Integer) where {TR<:AbstractFloat}\nsws_eigM!(M::AbstractMatrix{TR}, s::Integer, c::Complex, m::Integer, l_max::Integer) where {TR<:AbstractFloat}\n\nConstruct the spherical-spheroidal decomposition matrix truncated at l_max.\n\nArguments\n\nTR: Type for floating point conversion\ns::Integer: spin\nc::Complex: oblateness parameter\nm::Integer: azimuthal number\nl_max::Integer: maximum angular number\n\nReferences\n\nCook and Zalutskiy [CZ14]\nduetosymmetry/qnm\n\n\n\n\n\n","category":"method"},{"location":"utils/#Einstein.Utils.sws_eigen-Union{Tuple{TR}, Tuple{Type{TR}, Integer, Complex{TR}, Integer, Integer}} where TR<:AbstractFloat","page":"Utilities","title":"Einstein.Utils.sws_eigen","text":"sws_eigen(::Type{TR}, s::Integer, c::Complex{TR}, m::Integer, l_max::Integer) where {TR<:AbstractFloat}\n\nCalculate eigenvalues and eigenvectors of the spherical-spheroidal decomposition matrix.\n\nArguments\n\nTR: Type for floating point conversion\ns::Integer: spin\nc::Complex: oblateness parameter\nm::Integer: azimuthal number\nl_max::Integer: maximum angular number\n\nReferences\n\nCook and Zalutskiy [CZ14]\nduetosymmetry/qnm\n\n\n\n\n\n","category":"method"},{"location":"utils/#Einstein.Utils.sws_l_min-Tuple{Integer, Integer}","page":"Utilities","title":"Einstein.Utils.sws_l_min","text":"sws_l_min(s::Integer, m::Integer)\n\nMinimum allowed value of l for given s, m. Returns max(|s|, |m|).\n\nArguments\n\ns::Integer: spin\nm::Integer: azimuthal number\n\n\n\n\n\n","category":"method"}]
}
