var documenterSearchIndex = {"docs":
[{"location":"cheb/#Chebyshev-Suite","page":"Chebyshev Suite","title":"Chebyshev Suite","text":"","category":"section"},{"location":"cheb/","page":"Chebyshev Suite","title":"Chebyshev Suite","text":"Modules = [GRSuite.ChebyshevSuite]","category":"page"},{"location":"cheb/","page":"Chebyshev Suite","title":"Chebyshev Suite","text":"Modules = [GRSuite.ChebyshevSuite]","category":"page"},{"location":"cheb/#GRSuite.ChebyshevSuite.cheb1_angle-Union{Tuple{TI}, Tuple{TR}, Tuple{Type{TR}, TI}} where {TR<:AbstractFloat, TI<:Integer}","page":"Chebyshev Suite","title":"GRSuite.ChebyshevSuite.cheb1_angle","text":"cheb1_angle([TR=Float64], n::Integer)\n\nCompute angles for Chebyshev points of the first kind.\n\nArguments\n\nTR: Type parameter for the angles (e.g., Float64)\nn: Number of points\n\nReturns\n\nVector of n angles in [0,π], ordered decreasing\n\nMathematical Details\n\ntheta_k = frac(2k + 1)pi2n quad k = n-1ldots0\n\nThese angles generate first-kind Chebyshev points via: xk = -cos(θk)\n\n\n\n\n\n","category":"method"},{"location":"cheb/#GRSuite.ChebyshevSuite.cheb1_grid-Union{Tuple{TI}, Tuple{TR}, Tuple{Type{TR}, TI}} where {TR<:AbstractFloat, TI<:Integer}","page":"Chebyshev Suite","title":"GRSuite.ChebyshevSuite.cheb1_grid","text":"cheb1_grid([TR=Float64], n::Integer)\ncheb1_grid([TR=Float64], n::Integer, x_min::TR, x_max::TR)\n\nGenerate Chebyshev points of the first kind.\n\nArguments\n\nTR: Type parameter for the grid points (e.g., Float64)\nn: Number of points\nx_min: (Optional) Lower bound of the mapped interval\nx_max: (Optional) Upper bound of the mapped interval\n\nReturns\n\nVector of n Chebyshev points of the first kind\n\nMathematical Details\n\nFor the standard interval [-1,1]: x_k = -cosleft(frac(2k + 1)pi2nright) quad k = 01ldotsn-1\n\nFor mapped interval [xmin,xmax]: x_mapped = fracx_max + x_min2 + fracx_min - x_max2x_k\n\nNotes\n\nChebyshev points of the first kind are the roots of Chebyshev polynomials T_n(x). The convenience methods with Integer arguments default to Float64 precision.\n\nExamples\n\n# Generate 5 points on [-1,1]\nx = cheb1_grid(Float64, 5)\nx = cheb1_grid(5)  # Same as above\n\n# Generate 5 points mapped to [0,1]\nx = cheb1_grid(Float64, 5, 0.0, 1.0)\nx = cheb1_grid(5, 0.0, 1.0)  # Same as above\n\nSee also: cheb1_angle, cheb2_grid\n\n\n\n\n\n","category":"method"},{"location":"cheb/#GRSuite.ChebyshevSuite.cheb2_angle-Union{Tuple{TI}, Tuple{TR}, Tuple{Type{TR}, TI}} where {TR<:AbstractFloat, TI<:Integer}","page":"Chebyshev Suite","title":"GRSuite.ChebyshevSuite.cheb2_angle","text":"cheb2_angle([TR=Float64], n::Integer)\n\nCompute angles for Chebyshev points of the second kind.\n\nArguments\n\nTR: Type parameter for the angles (e.g., Float64)\nn: Number of points\n\nReturns\n\nVector of n angles in [0,π], ordered decreasing\nEmpty vector if n=0\n[π/2] if n=1\n\nMathematical Details\n\nFor n > 1: theta_k = frackpin-1 quad k = n-1ldots0\n\nThese angles generate second-kind Chebyshev points via: xk = -cos(θk)\n\n\n\n\n\n","category":"method"},{"location":"cheb/#GRSuite.ChebyshevSuite.cheb2_asmat-Union{Tuple{TI}, Tuple{TR}, Tuple{Type{TR}, TI}} where {TR<:AbstractFloat, TI<:Integer}","page":"Chebyshev Suite","title":"GRSuite.ChebyshevSuite.cheb2_asmat","text":"cheb2_asmat([TR=Float64], n::Integer)\n\nGenerate the analysis and synthesis matrices for Chebyshev spectral methods.\n\nArguments\n\nTR: Type parameter for the matrix elements (e.g., Float64)\nn: Size of the matrices (n×n)\n\nReturns\n\nTuple{Matrix{TR}, Matrix{TR}}: A tuple containing:\nAnalysis matrix A (n×n)\nSynthesis matrix S (n×n)\n\nMathematical Background\n\nThe analysis and synthesis matrices are used for transforming between physical and spectral spaces in Chebyshev spectral methods.\n\nFor a function f(x) evaluated at Chebyshev points, these matrices allow:\n\nTransformation to spectral coefficients: hatf = Af\nTransformation back to physical space: f = Shatf\n\nThe matrices are constructed using:\n\nS_ij = epsilon_j cosleft(fracpi i jN-1right)\n\nA_ji = frac2c_ic_jN-1S_ij\n\nwhere:\n\nc_k = begincases 12  k=0 text or  k=N-1  1  textotherwise endcases\nepsilon_j = (-1)^j\nij = 0ldotsN-1\n\nExamples\n\n# Generate 8×8 analysis and synthesis matrices with Float64 precision\nA, S = cheb2_asmat(Float64, 8)\n\n# Transform function values to spectral coefficients\nf_values = [sin(x) for x in cheb2_grid(Float64, 8)]\nf_coeffs = A * f_values\n\n# Transform back to physical space\nf_recovered = S * f_coeffs\n\nSee also: cheb2_grid\n\n\n\n\n\n","category":"method"},{"location":"cheb/#GRSuite.ChebyshevSuite.cheb2_coeffs_intmat-Union{Tuple{TI}, Tuple{TR}, Tuple{Type{TR}, TI}} where {TR<:AbstractFloat, TI<:Integer}","page":"Chebyshev Suite","title":"GRSuite.ChebyshevSuite.cheb2_coeffs_intmat","text":"cheb2_coeffs_intmat([TR=Float64], n::Integer)\ncheb2_coeffs_intmat([TR=Float64], n::Integer, x_min::TR, x_max::TR)\n\nGenerate the Chebyshev coefficient integration matrix for spectral integration.\n\nArguments\n\nTR: Type parameter for the matrix elements (e.g., Float64)\nn: Size of the matrix (n×n)\nx_min: (Optional) Lower bound of the integration interval\nx_max: (Optional) Upper bound of the integration interval\n\nReturns\n\nMatrix{TR}: The integration matrix B (n×n)\n\nMathematical Background\n\nThe integration matrix B operates on Chebyshev spectral coefficients to compute the coefficients of the indefinite integral. For a function expressed in the  Chebyshev basis:\n\nf(x) = sum_k=0^N-1 a_k T_k(x)\n\nThe indefinite integral's coefficients b_k in:\n\nint f(x)dx = sum_k=0^N-1 b_k T_k(x) + C\n\nare computed using the matrix B: b = Ba\n\nThe matrix elements are derived from the integration relation of Chebyshev polynomials:\n\nint T_n(x)dx = frac12left(fracT_n+1(x)n+1 - fracT_n-1(x)n-1right)\n\nWhen x_min and x_max are provided, the matrix is scaled for integration over [xmin, xmax].\n\nExamples\n\n# Generate 8×8 integration matrix for [-1,1]\nB = cheb2_coeffs_intmat(Float64, 8)\n\n# Get Chebyshev coefficients of sin(x) using cheb2_asmat\nA, _ = cheb2_asmat(Float64, 8)\nx = cheb2_grid(Float64, 8)\nf = sin.(x)\na = A * f  # Chebyshev coefficients of sin(x)\n\n# Compute coefficients of indefinite integral\nb = B * a  # Chebyshev coefficients of -cos(x) + C\n\nSee also: cheb2_grid, cheb2_asmat\n\n\n\n\n\n","category":"method"},{"location":"cheb/#GRSuite.ChebyshevSuite.cheb2_grid-Union{Tuple{TI}, Tuple{TR}, Tuple{Type{TR}, TI}} where {TR<:AbstractFloat, TI<:Integer}","page":"Chebyshev Suite","title":"GRSuite.ChebyshevSuite.cheb2_grid","text":"cheb2_grid([TR=Float64], n::Integer)\ncheb2_grid([TR=Float64], n::Integer, x_min::TR, x_max::TR)\n\nGenerate Chebyshev points of the second kind.\n\nArguments\n\nTR: Type parameter for the grid points (e.g., Float64)\nn: Number of points\nx_min: (Optional) Lower bound of the mapped interval\nx_max: (Optional) Upper bound of the mapped interval\n\nReturns\n\nVector of n Chebyshev points of the second kind\n\nMathematical Details\n\nFor the standard interval [-1,1]: x_k = -cosleft(frackpin-1right) quad k = 01ldotsn-1\n\nFor mapped interval [xmin,xmax]: x_mapped = fracx_max + x_min2 + fracx_min - x_max2x_k\n\nNotes\n\nChebyshev points of the second kind are the extrema of Chebyshev polynomials T_n(x). These points include the endpoints, making them suitable for boundary value problems. The convenience methods with Integer arguments default to Float64 precision.\n\nExamples\n\n# Generate 5 points on [-1,1]\nx = cheb2_grid(Float64, 5)\nx = cheb2_grid(5)  # Same as above\n\n# Generate 5 points mapped to [0,π]\nx = cheb2_grid(Float64, 5, 0.0, π)\nx = cheb2_grid(5, 0.0, π)  # Same as above\n\nSee also: cheb2_angle, cheb1_grid\n\n\n\n\n\n","category":"method"},{"location":"cheb/#GRSuite.ChebyshevSuite.cheb2_interp-Union{Tuple{VT3}, Tuple{VT2}, Tuple{VT1}, Tuple{TR}, Tuple{VT1, VT2, VT3, TR}} where {TR<:AbstractFloat, VT1<:AbstractVector{TR}, VT2<:AbstractVector{TR}, VT3<:AbstractVector{TR}}","page":"Chebyshev Suite","title":"GRSuite.ChebyshevSuite.cheb2_interp","text":"cheb2_interp(w::VT1, x::VT2, f::VT3, x0::TR) where {\n    TR<:AbstractFloat,\n    VT1<:AbstractVector{TR},\n    VT2<:AbstractVector{TR},\n    VT3<:AbstractVector{TR},\n}\n\nEvaluate a polynomial interpolant using the barycentric interpolation formula.\n\nArguments\n\nw: Vector of barycentric weights\nx: Vector of interpolation points (typically Chebyshev points)\nf: Vector of function values at interpolation points\nx0: Point at which to evaluate the interpolant\n\nReturns\n\nInterpolated value at x0\n\nMathematical Details\n\nThe barycentric interpolation formula is:\n\np(x) = begincases\nf_j  textif  x = x_j text for some  j \nfracsum_j=0^n-1 fracw_jx-x_jf_jsum_j=0^n-1 fracw_jx-x_j  textotherwise\nendcases\n\nThis formula provides a numerically stable way to evaluate the Lagrange interpolation polynomial. When used with Chebyshev points and their corresponding barycentric weights, it gives optimal interpolation properties.\n\nExamples\n\n# Set up interpolation points and weights\nn = 10\nx = cheb2_grid(Float64, n)\nw = cheb2_interp_wts(Float64, n)\n\n# Function to interpolate\nf = sin.(π .* x)\n\n# Evaluate interpolant at a point\nx0 = 0.5\ny = cheb2_interp(w, x, f, x0)\n\nReference\n\nSalzer [Sal72]\nTrefethen [Tre19]\nchebfun/@chebtech2/bary.m at master · chebfun/chebfun\n\nSee also: cheb2_interp_wts, cheb2_grid\n\n\n\n\n\n","category":"method"},{"location":"cheb/#GRSuite.ChebyshevSuite.cheb2_interp_wts-Union{Tuple{TI}, Tuple{TR}, Tuple{Type{TR}, TI}} where {TR<:AbstractFloat, TI<:Integer}","page":"Chebyshev Suite","title":"GRSuite.ChebyshevSuite.cheb2_interp_wts","text":"cheb2_interp_wts([TR=Float64], n::Integer)\n\nCompute the barycentric weights for Chebyshev points of the second kind.\n\nArguments\n\nTR: Type parameter for the weights (e.g., Float64)\nn: Number of points\n\nReturns\n\nVector of n barycentric weights\n\nMathematical Details\n\nFor Chebyshev points of the second kind, the barycentric weights are:\n\nw_j = (-1)^j delta_j quad j = 0ldotsn-1\n\nwhere delta_j is defined as:\n\ndelta_j = begincases\n12  j = 0 text or  j = n-1 \n1  textotherwise\nendcases\n\nThese weights are optimized for numerical stability and efficiency in the barycentric interpolation formula.\n\nSee also: cheb2_interp, cheb2_grid\n\n\n\n\n\n","category":"method"},{"location":"cheb/#GRSuite.ChebyshevSuite.cheb2_intmat-Union{Tuple{TI}, Tuple{TR}, Tuple{Type{TR}, TI}} where {TR<:AbstractFloat, TI<:Integer}","page":"Chebyshev Suite","title":"GRSuite.ChebyshevSuite.cheb2_intmat","text":"cheb2_intmat([TR=Float64], n::Integer)\ncheb2_intmat([TR=Float64], n::Integer, x_min::TR, x_max::TR)\n\nGenerate the Chebyshev integration matrix that operates directly on function values.\n\nArguments\n\nTR: Type parameter for the matrix elements (e.g., Float64)\nn: Size of the matrix (n×n)\nx_min: (Optional) Lower bound of the integration interval\nx_max: (Optional) Upper bound of the integration interval\n\nReturns\n\nMatrix{TR}: The integration matrix that operates on function values\n\nMathematical Background\n\nThis matrix directly computes the indefinite integral of a function from its values at Chebyshev points. For a function f(x), the integral is computed as:\n\nint f(x)dx = mathbfIf\n\nwhere mathbfI = S B A is the integration matrix composed of:\n\nA: Analysis matrix (transform to spectral coefficients)\nB: Coefficient integration matrix\nS: Synthesis matrix (transform back to physical space)\n\nThis composition allows integration in physical space through:\n\nTransform to spectral space (A)\nIntegrate coefficients (B)\nTransform back to physical space (S)\n\nExamples\n\n# Generate 8×8 integration matrix for [-1,1]\nI = cheb2_intmat(Float64, 8)\n\n# Get function values at Chebyshev points\nx = cheb2_grid(Float64, 8)\nf = sin.(x)\n\n# Compute indefinite integral (-cos(x) + C)\nF = I * f\n\n# Integration matrix for [0,π]\nI_scaled = cheb2_intmat(Float64, 8, 0.0, π)\n\nSee also: cheb2_coeffs_intmat, cheb2_asmat, cheb2_grid\n\n\n\n\n\n","category":"method"},{"location":"cheb/#GRSuite.ChebyshevSuite.cheb2_quad_wts-Union{Tuple{TI}, Tuple{TR}, Tuple{Type{TR}, TI}} where {TR<:AbstractFloat, TI<:Integer}","page":"Chebyshev Suite","title":"GRSuite.ChebyshevSuite.cheb2_quad_wts","text":"cheb2_quad_wts([TR=Float64], n::Integer)\n\nCompute quadrature weights for Chebyshev points of the second kind (Clenshaw-Curtis quadrature).\n\nArguments\n\nTR: Type parameter for the weights (e.g., Float64)\nn: Number of points\n\nReturns\n\nVector of n weights for Clenshaw-Curtis quadrature\n\nMathematical Background\n\nFor a function expressed in the Chebyshev basis:\n\nf(x) = sum_k=0^n c_k T_k(x)\n\nThe definite integral can be expressed as:\n\nint_-1^1 f(x)dx = mathbfv^Tmathbfc\n\nwhere mathbfv contains the integrals of Chebyshev polynomials:\n\nv_k = int_-1^1 T_k(x)dx = begincases\nfrac21-k^2  k text even \n0  k text odd\nendcases\n\nThe quadrature weights mathbfw satisfy:\n\nint_-1^1 f(x)dx approx sum_j=1^n w_j f(x_j)\n\nAlgorithm\n\nUses Waldvogel's algorithm (2006) with modifications by Nick Hale:\n\nCompute exact integrals of even-indexed Chebyshev polynomials\nMirror the sequence for DCT via FFT\nApply inverse FFT\nAdjust boundary weights\n\nEdge Cases\n\nn = 0: Returns empty vector\nn = 1: Returns [2.0]\nn ≥ 2: Returns full set of weights\n\nExamples\n\n# Compute weights for 5-point quadrature\nw = cheb2_quad_wts(5)\n\n# Integrate sin(x) from -1 to 1\nx = cheb2_grid(5)\nf = sin.(x)\nI = dot(w, f)  # ≈ 0\n\nReferences\n\nWaldvogel [Wal06]\nFast Clenshaw-Curtis Quadrature - File Exchange - MATLAB Central\n\n\n\n\n\n","category":"method"},{"location":"cheb/","page":"Chebyshev Suite","title":"Chebyshev Suite","text":"B. Fornberg. Generation of finite difference formulas on arbitrarily spaced grids. Mathematics of computation 51, 699–706 (1988).\n\n\n\nB. Fornberg. Classroom Note:Calculation of Weights in Finite Difference Formulas. SIAM Review 40, 685–691 (1998), arXiv:https://doi.org/10.1137/S0036144596322507.\n\n\n\nB. Fornberg. An algorithm for calculating Hermite-based finite difference weights. IMA Journal of Numerical Analysis 41, 801–813 (2021).\n\n\n\nH. E. Salzer. Lagrangian interpolation at the Chebyshev points xn, nuequiv cos (nupi/n), nu= 0 (1) n; some unnoted advantages. The Computer Journal 15, 156–159 (1972).\n\n\n\nL. N. Trefethen. Approximation Theory and Approximation Practice, Extended Edition (Society for Industrial and Applied Mathematics, Philadelphia, PA, 2019), arXiv:https://epubs.siam.org/doi/pdf/10.1137/1.9781611975949.\n\n\n\nJ. Waldvogel. Fast construction of the Fejér and Clenshaw–Curtis quadrature rules. BIT Numerical Mathematics 46, 195–202 (2006).\n\n\n\n","category":"page"},{"location":"fdm/#Finite-Difference-Suite","page":"Finite Difference Suite","title":"Finite Difference Suite","text":"","category":"section"},{"location":"fdm/","page":"Finite Difference Suite","title":"Finite Difference Suite","text":"Modules = [GRSuite.FiniteDifferenceSuite]","category":"page"},{"location":"fdm/","page":"Finite Difference Suite","title":"Finite Difference Suite","text":"Modules = [GRSuite.FiniteDifferenceSuite]","category":"page"},{"location":"fdm/#GRSuite.FiniteDifferenceSuite.fdm_grid-Union{Tuple{TR}, Tuple{Type{TR}, TR, TR, TR}} where TR<:AbstractFloat","page":"Finite Difference Suite","title":"GRSuite.FiniteDifferenceSuite.fdm_grid","text":"fdm_grid(::Type{TR}, x_min::TR, x_max::TR, dx::TR) where {TR<:AbstractFloat}\n\nGenerate a uniform grid for finite difference methods.\n\nArguments\n\nTR: Type parameter for the grid points (e.g., Float64)\nx_min: Lower bound of the interval\nx_max: Upper bound of the interval\ndx: Grid spacing\n\nReturns\n\nVector of n uniformly spaced points, where n = round((xmax - xmin)/dx) + 1\n\nMathematical Details\n\nThe grid points are generated as:\n\nx_i = x_min + (i-1)dx quad i = 1ldotsn\n\nwhere n is chosen to ensure the grid covers [xmin, xmax] with spacing dx.\n\nNotes\n\nThe function ensures that x_max is accurately represented within floating-point precision\nThe actual number of points is computed to maintain uniform spacing\nThe final point may differ from x_max by at most machine epsilon\n\nExamples\n\n# Generate grid with spacing 0.1 on [0,1]\nx = fdm_grid(Float64, 0.0, 1.0, 0.1)\n\n# Generate grid with 100 points on [-1,1]\ndx = 2.0/99  # To get exactly 100 points\nx = fdm_grid(Float64, -1.0, 1.0, dx)\n\n\n\n\n\n","category":"method"},{"location":"fdm/#GRSuite.FiniteDifferenceSuite.fornberg_calculate_weights-Union{Tuple{VT}, Tuple{T2}, Tuple{T}, Tuple{Int64, T, VT}} where {T<:Real, T2<:Real, VT<:AbstractVector{T2}}","page":"Finite Difference Suite","title":"GRSuite.FiniteDifferenceSuite.fornberg_calculate_weights","text":"fornberg_calculate_weights([T=Float64], order::Integer, x0::Real, x::AbstractVector; \n                         dfdx::Bool=false)\n\nCalculate finite difference weights for arbitrary-order derivatives using the Fornberg algorithm.\n\nArguments\n\nT: Type parameter for the weights (defaults to type of x0)\norder: Order of the derivative to approximate\nx0: Point at which to approximate the derivative\nx: Grid points to use in the approximation\ndfdx: Whether to include first derivative values (Hermite finite differences)\n\nReturns\n\nIf dfdx == false:\n\nVector{T}: Weights for function values\n\nIf dfdx == true:\n\nTuple{Vector{T}, Vector{T}}: Weights for (function values, derivative values)\n\nMathematical Background\n\nFor a function f(x), the derivative approximation takes the form:\n\nIf dfdx == false (standard finite differences):\n\nf^(n)(x_0) approx sum_j=1^N c_j f(x_j)\n\nIf dfdx == true (Hermite finite differences):\n\nf^(n)(x_0) approx sum_j=1^N d_j f(x_j) + e_j f(x_j)\n\nRequirements\n\nFor standard finite differences: N > order\nFor Hermite finite differences: N > order/2 + 1\n\nwhere N is the length of x\n\nExamples\n\n# Standard central difference for first derivative\nx = [-1.0, 0.0, 1.0]\nw = fornberg_calculate_weights(1, 0.0, x)\n# Returns approximately [-0.5, 0.0, 0.5]\n\n# Forward difference for second derivative\nx = [0.0, 1.0, 2.0, 3.0]\nw = fornberg_calculate_weights(2, 0.0, x)\n\n# Hermite finite difference for third derivative\nx = [-1.0, 0.0, 1.0]\nw_f, w_d = fornberg_calculate_weights(3, 0.0, x, dfdx=true)\n\nReferences\n\nFornberg [For88]\nFornberg [For21]\nFornberg [For98]\nMethodOfLines.jl/src/discretization/schemes/fornbergcalculateweights.jl at master · SciML/MethodOfLines.jl\nprecision - Numerical derivative and finite difference coefficients: any update of the Fornberg method? - Computational Science Stack Exchange\n\nNotes\n\nThe implementation includes a stability correction for higher-order derivatives\nFor first derivatives (order=1), the weights sum to zero\nThe algorithm handles both uniform and non-uniform grids\nWhen using Hermite finite differences, fewer points are needed but derivatives must be available\n\nSee also: fdm_grid\n\n\n\n\n\n","category":"method"},{"location":"fdm/","page":"Finite Difference Suite","title":"Finite Difference Suite","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = GRSuite","category":"page"},{"location":"#GRSuite","page":"Home","title":"GRSuite","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for GRSuite.","category":"page"},{"location":"","page":"Home","title":"Home","text":"warning: AI-Generated Documentation\nMost of the documentation in this package was generated with the assistance of AI. If you find any issues or areas that need clarification, please open an issue on GitHub.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [GRSuite]","category":"page"}]
}
