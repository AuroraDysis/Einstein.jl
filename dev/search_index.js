var documenterSearchIndex = {"docs":
[{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"M. C. Babiuc and others. Implementation of standard testbeds for numerical relativity. Class. Quant. Grav. 25, 125012 (2008), arXiv:0709.3559 [gr-qc].\n\n\n\nJ.-P. Berrut and L. N. Trefethen. Barycentric lagrange interpolation. SIAM review 46, 501–517 (2004).\n\n\n\nG. B. Cook and M. Zalutskiy. Gravitational perturbations of the Kerr geometry: High-accuracy study. Phys. Rev. D 90, 124021 (2014), arXiv:1410.7698 [gr-qc].\n\n\n\nS. R. Dolan and A. C. Ottewill. On an Expansion Method for Black Hole Quasinormal Modes and Regge Poles. Class. Quant. Grav. 26, 225003 (2009), arXiv:0908.0329 [gr-qc].\n\n\n\nB. Fornberg. Generation of finite difference formulas on arbitrarily spaced grids. Mathematics of computation 51, 699–706 (1988).\n\n\n\nB. Fornberg. Classroom Note:Calculation of Weights in Finite Difference Formulas. SIAM Review 40, 685–691 (1998), arXiv:https://doi.org/10.1137/S0036144596322507.\n\n\n\nB. Fornberg. An algorithm for calculating Hermite-based finite difference weights. IMA Journal of Numerical Analysis 41, 801–813 (2021).\n\n\n\nD. Hilditch, A. Weyhausen and B. Brügmann. Pseudospectral method for gravitational wave collapse. Phys. Rev. D 93, 063006 (2016), arXiv:1504.04732 [gr-qc].\n\n\n\nJ. L. Jaramillo, R. Panosso Macedo and L. Al Sheikh. Pseudospectrum and Black Hole Quasinormal Mode Instability. Phys. Rev. X 11, 031003 (2021), arXiv:2004.06434 [gr-qc].\n\n\n\nW. J. Lentz. Generating Bessel functions in Mie scattering calculations using continued fractions. Applied optics 15, 668–671 (1976).\n\n\n\nV. Mehrmann and H. Voss. Nonlinear eigenvalue problems: A challenge for modern eigenvalue methods. GAMM-Mitteilungen 27, 121–152 (2004).\n\n\n\nR. M. Neal. Fast exact summation using small and large superaccumulators (2015), arXiv:1505.05571 [cs.NA].\n\n\n\nR. Panosso Macedo. Hyperboloidal approach for static spherically symmetric spacetimes: a didactical introductionand applications in black-hole physics. Phil. Trans. Roy. Soc. Lond. A 382, 20230046 (2024), arXiv:2307.15735 [gr-qc].\n\n\n\nW. H. Press. Numerical recipes 3rd edition: The art of scientific computing (Cambridge university press, 2007).\n\n\n\nJ. Ripley. *JLRipley314/teuk-fortran-2020: Teuk-                Fortran-2020-v1.1                * (Aug 2023).\n\n\n\nJ. L. Ripley. Computing the quasinormal modes and eigenfunctions for the Teukolsky equation using horizon penetrating, hyperboloidally compactified coordinates. Class. Quant. Grav. 39, 145009 (2022), arXiv:2202.03837 [gr-qc].\n\n\n\nL. C. Stein, qnm: A Python package for calculating Kerr quasinormal modes, separation constants, and spherical-spheroidal mixing coefficients. J. Open Source Softw. 4, 1683 (2019), arXiv:1908.10377 [gr-qc].\n\n\n\nB. Szilagyi, L. Lindblom and M. A. Scheel. Simulations of Binary Black Hole Mergers Using Spectral Methods. Phys. Rev. D 80, 124010 (2009), arXiv:0909.3557 [gr-qc].\n\n\n\nN. M. Temme. DLMF: §3.10 Continued Fractions ‣ Areas ‣ Chapter 3 Numerical Methods, https://dlmf.nist.gov/3.10 (09 2024) (Accessed on 09/19/2024).\n\n\n\nI. J. Thompson and A. R. Barnett. Coulomb and Bessel functions of complex arguments and order. Journal of Computational Physics 64, 490–509 (1986).\n\n\n\n","category":"page"},{"location":"cheb/#Chebyshev-Suite","page":"Chebyshev Suite","title":"Chebyshev Suite","text":"","category":"section"},{"location":"cheb/","page":"Chebyshev Suite","title":"Chebyshev Suite","text":"Modules = [Einstein.ChebyshevSuite]","category":"page"},{"location":"cheb/","page":"Chebyshev Suite","title":"Chebyshev Suite","text":"Modules = [Einstein.ChebyshevSuite]","category":"page"},{"location":"cheb/#Einstein.ChebyshevSuite.ChebyshevAnalysis","page":"Chebyshev Suite","title":"Einstein.ChebyshevSuite.ChebyshevAnalysis","text":"ChebyshevAnalysis(grid::ChebyshevGrid)\n\nConstruct a Chebyshev analysis operator for the given grid, converting from coefficients to values.\n\n\n\n\n\n","category":"type"},{"location":"cheb/#Einstein.ChebyshevSuite.ChebyshevCoefficientsIntegration","page":"Chebyshev Suite","title":"Einstein.ChebyshevSuite.ChebyshevCoefficientsIntegration","text":"cheb_coeffs_integrate(coeffs::AbstractVector{TR}) where {TR<:AbstractFloat}\nChebyshevCoefficientsIntegration{[TR=Float64]}(n::TI)(coeffs::AbstractVector{TR}) where {TR<:AbstractFloat,TI<:Integer}\n\nCompute the indefinite integral of a function given its Chebyshev coefficients.\n\nArguments\n\ncoeffs: Vector of Chebyshev coefficients of the function to be integrated\n\nReferences\n\nchebfun/@chebtech/cumsum.m at master · chebfun/chebfun\n\n\n\n\n\n","category":"type"},{"location":"cheb/#Einstein.ChebyshevSuite.ChebyshevFirstKindAnalysis","page":"Chebyshev Suite","title":"Einstein.ChebyshevSuite.ChebyshevFirstKindAnalysis","text":"cheb1_vals2coeffs(vals::AbstractVector{TF}) where {TF<:AbstractFloat}\nChebyshevFirstKindAnalysis{[TF=Float64]}(n::Integer)(vals::VT) where {TF<:AbstractFloat}\n\nConvert values at Chebyshev points of the 1st kind into Chebyshev coefficients.\n\nPerformance Guide\n\nFor best performance, especially in loops or repeated calls:\n\nop = ChebyshevFirstKindAnalysis{Float64}(n)\nvalues = op(coeffs)\n\nReferences\n\nchebfun/@chebtech1/vals2coeffs.m at master · chebfun/chebfun\n\n\n\n\n\n","category":"type"},{"location":"cheb/#Einstein.ChebyshevSuite.ChebyshevFirstKindSynthesis","page":"Chebyshev Suite","title":"Einstein.ChebyshevSuite.ChebyshevFirstKindSynthesis","text":"cheb1_coeffs2vals(coeffs::AbstractVector{TFC}) where {TFC<:AbstractFloatOrComplex}\nChebyshevFirstKindSynthesis{[TF=Float64]}(n::Integer)(coeffs::AbstractVector{TFC})\n\nConvert Chebyshev coefficients to values at Chebyshev points of the 1st kind.\n\nPerformance Guide\n\nFor best performance, especially in loops or repeated calls:\n\nop = ChebyshevFirstKindSynthesis{Float64}(n)\nvalues = op(coeffs)\n\nReferences\n\nchebfun/@chebtech1/coeffs2vals.m at master · chebfun/chebfun\n\n\n\n\n\n","category":"type"},{"location":"cheb/#Einstein.ChebyshevSuite.ChebyshevGrid","page":"Chebyshev Suite","title":"Einstein.ChebyshevSuite.ChebyshevGrid","text":"ChebyshevGrid{TF,TNode}(n, lower_bound, upper_bound, kind=ChebyshevNode.SecondKind) where TF<:AbstractFloat\n\nBuild a Chebyshev grid of size n in the interval [lower_bound, upper_bound]. The grid can be of the first or second kind.\n\nNode Types\n\nChebyshevNode.FirstKind: The Chebyshev nodes of the first kind (zeros of the Chebyshev polynomials)\nChebyshevNode.SecondKind: The Chebyshev nodes of the second kind (Chebyshev–Lobatto points)\n\nArguments\n\nn::Integer: Number of grid points\nlower_bound::TF: Lower bound of the interval\nupper_bound::TF: Upper bound of the interval\nkind::ChebyshevNode.T = ChebyshevNode.SecondKind: Kind of Chebyshev nodes\n\n\n\n\n\n","category":"type"},{"location":"cheb/#Einstein.ChebyshevSuite.ChebyshevInterpolation","page":"Chebyshev Suite","title":"Einstein.ChebyshevSuite.ChebyshevInterpolation","text":"ChebyshevInterpolation(grid::ChebyshevGrid{TF,TNode}) where {TF<:AbstractFloat,TNode<:AbstractChebyshevNode}\n\nConstruct a barycentric interpolation with precomputed weights for a Chebyshev grid.\n\n\n\n\n\n","category":"type"},{"location":"cheb/#Einstein.ChebyshevSuite.ChebyshevSecondKindAnalysis","page":"Chebyshev Suite","title":"Einstein.ChebyshevSuite.ChebyshevSecondKindAnalysis","text":"cheb2_vals2coeffs(vals::AbstractVector{TF}) where {TF<:AbstractFloat}\nChebyshevSecondKindAnalysis{[TF=Float64]}(n::Integer)(vals::AbstractVector{TF}) where {TF<:AbstractFloat}\n\nConvert values at Chebyshev points of the 2nd kind into Chebyshev coefficients.\n\nPerformance Guide\n\nFor best performance, especially in loops or repeated calls:\n\nop = ChebyshevSecondKindAnalysis{Float64}(n)\nvalues = op(coeffs)\n\nReferences\n\nchebfun/@chebtech2/vals2coeffs.m at master · chebfun/chebfun\n\n\n\n\n\n","category":"type"},{"location":"cheb/#Einstein.ChebyshevSuite.ChebyshevSecondKindSynthesis","page":"Chebyshev Suite","title":"Einstein.ChebyshevSuite.ChebyshevSecondKindSynthesis","text":"cheb2_coeffs2vals(coeffs::AbstractVector{TR}) where {TR<:AbstractFloatOrComplex}\nChebyshevSecondKindSynthesis{[TF=Float64]}(n::Integer)(coeffs::AbstractVector{TR})\n\nConvert Chebyshev coefficients to values at Chebyshev points of the 2nd kind.\n\nPerformance Guide\n\nFor best performance, especially in loops or repeated calls:\n\nop = ChebyshevSecondKindSynthesis{Float64}(n)\nvalues = op(coeffs)\n\nReferences\n\nchebfun/@chebtech2/coeffs2vals.m at master · chebfun/chebfun\n\n\n\n\n\n","category":"type"},{"location":"cheb/#Einstein.ChebyshevSuite.ChebyshevSynthesis","page":"Chebyshev Suite","title":"Einstein.ChebyshevSuite.ChebyshevSynthesis","text":"ChebyshevSynthesis(grid::ChebyshevGrid)\n\nConstruct a Chebyshev synthesis operator for the given grid, converting from coefficients to values.\n\n\n\n\n\n","category":"type"},{"location":"cheb/#Einstein.ChebyshevSuite.bary_diffmat-Union{Tuple{TR}, Tuple{AbstractVector{TR}, AbstractVector{TR}, Integer, AbstractVector{TR}}} where TR<:AbstractFloat","page":"Chebyshev Suite","title":"Einstein.ChebyshevSuite.bary_diffmat","text":"bary_diffmat(x; w=nothing, k=1, t=nothing)\n\nCompute the barycentric differentiation matrix.\n\nReferences:\n\nchebfun/@chebcolloc/baryDiffMat.m at master · chebfun/chebfun\n\n\n\n\n\n","category":"method"},{"location":"cheb/#Einstein.ChebyshevSuite.cheb1_analysis_matrix-Union{Tuple{TF}, Tuple{Type{TF}, Integer}} where TF<:AbstractFloat","page":"Chebyshev Suite","title":"Einstein.ChebyshevSuite.cheb1_analysis_matrix","text":"cheb1_analysis_matrix([TF=Float64], n::Integer) where {TF<:AbstractFloat}\n\nConstruct the analysis matrix A that transforms function values at Chebyshev points of the 1st kind to Chebyshev coefficients.\n\nArguments\n\nTF: Element type (defaults to Float64)\nn: Number of points/coefficients\n\n\n\n\n\n","category":"method"},{"location":"cheb/#Einstein.ChebyshevSuite.cheb1_angles-Union{Tuple{TF}, Tuple{Type{TF}, Integer}} where TF<:AbstractFloat","page":"Chebyshev Suite","title":"Einstein.ChebyshevSuite.cheb1_angles","text":"cheb1_angles(TF, n) where {TF<:AbstractFloat}\n\nCompute angles for Chebyshev points of the 1st kind:\n\ntheta_k = frac(2k + 1)pi2n quad k = n-1ldots0\n\nArguments\n\nTF: Type parameter for the angles (e.g., Float64)\nn: Number of points\n\n\n\n\n\n","category":"method"},{"location":"cheb/#Einstein.ChebyshevSuite.cheb1_barycentric_weights-Union{Tuple{TF}, Tuple{Type{TF}, Integer}} where TF<:AbstractFloat","page":"Chebyshev Suite","title":"Einstein.ChebyshevSuite.cheb1_barycentric_weights","text":"cheb1_barycentric_weights([TF=Float64], n::Integer) where {TF<:AbstractFloat}\n\nCompute the barycentric weights for Chebyshev points of the 1st kind.\n\nArguments\n\nTF: Type parameter for the weights (e.g., Float64)\nn: Number of points\n\nReferences\n\nBerrut and Trefethen [BT04]\nchebfun/@chebtech1/barywts.m at master · chebfun/chebfun\n\nSee also: BarycentricInterpolation, cheb1_points\n\n\n\n\n\n","category":"method"},{"location":"cheb/#Einstein.ChebyshevSuite.cheb1_differentiation_matrix-Union{Tuple{TR}, Tuple{Type{TR}, Integer}, Tuple{Type{TR}, Integer, Integer}} where TR<:AbstractFloat","page":"Chebyshev Suite","title":"Einstein.ChebyshevSuite.cheb1_differentiation_matrix","text":"cheb1_differentiation_matrix([TR=Float64], n::Integer, k::Integer=1) where {TR<:AbstractFloat}\n\nConstruct a Chebyshev differentiation that maps function values at n Chebyshev points of the 1st kind  to values of the k-th derivative of the interpolating polynomial at those points.\n\nArguments\n\nTR: Element type (defaults to Float64)\nn::Integer: Number of Chebyshev points\nk::Integer=1: Order of the derivative (default: 1)\n\nReferences\n\nchebfun/@chebcolloc1/chebcolloc1.m at master · chebfun/chebfun\n\n\n\n\n\n","category":"method"},{"location":"cheb/#Einstein.ChebyshevSuite.cheb1_integration_matrix-Union{Tuple{TF}, Tuple{Type{TF}, Integer}} where TF<:AbstractFloat","page":"Chebyshev Suite","title":"Einstein.ChebyshevSuite.cheb1_integration_matrix","text":"cheb1_integration_matrix([TF=Float64], n::Integer) where {TF<:AbstractFloat}\ncheb1_integration_matrix([TF=Float64], n::Integer, x_min::TF, x_max::TF) where {TF<:AbstractFloat}\n\nCompute Chebyshev integration matrix that maps function values at n Chebyshev points of the 1st kind to values of the integral of the interpolating polynomial at those points, with the convention that the first value is zero.\n\nReferences\n\nchebfun/@chebcolloc1/chebcolloc1.m at master · chebfun/chebfun\n\n\n\n\n\n","category":"method"},{"location":"cheb/#Einstein.ChebyshevSuite.cheb1_points-Union{Tuple{TF}, Tuple{Type{TF}, Integer}} where TF<:AbstractFloat","page":"Chebyshev Suite","title":"Einstein.ChebyshevSuite.cheb1_points","text":"cheb1_points([TF=Float64], n::Integer) where {TF<:AbstractFloat}\ncheb1_points([TF=Float64], n::Integer, x_min::TF, x_max::TF) where {TF<:AbstractFloat}\n\nGenerate Chebyshev points of the 2nd kind.\n\nFor the standard interval [-1,1]:\n\nx_k = -cosleft(frac(2k + 1)pi2nright) quad k = 01ldotsn-1\n\nFor mapped interval [xmin,xmax]:\n\nx_mathrmmapped = fracx_mathrmmax + x_mathrmmin2 + fracx_mathrmmin - x_mathrmmax2x_k\n\nArguments\n\nTF: Type parameter for the grid points (e.g., Float64)\nn: Number of points\nx_min: (Optional) Lower bound of the mapped interval\nx_max: (Optional) Upper bound of the mapped interval\n\nReferences\n\nchebfun/@chebtech1/chebpts.m at master · chebfun/chebfun\n\n\n\n\n\n","category":"method"},{"location":"cheb/#Einstein.ChebyshevSuite.cheb1_quadrature_weights-Union{Tuple{TF}, Tuple{Type{TF}, Integer}} where TF<:AbstractFloat","page":"Chebyshev Suite","title":"Einstein.ChebyshevSuite.cheb1_quadrature_weights","text":"cheb1_quadrature_weights([TF=Float64], n::Integer) where {TF<:AbstractFloat}\n\nCompute quadrature weights for Chebyshev points of the 1st kind.\n\nArguments\n\nTF: Type parameter for the weights (e.g., Float64)\nn: Number of points\n\nReferences\n\nchebfun/@chebtech1/quadwts.m at master · chebfun/chebfun\n\n\n\n\n\n","category":"method"},{"location":"cheb/#Einstein.ChebyshevSuite.cheb1_synthesis_matrix-Union{Tuple{TF}, Tuple{Type{TF}, Integer}} where TF<:AbstractFloat","page":"Chebyshev Suite","title":"Einstein.ChebyshevSuite.cheb1_synthesis_matrix","text":"cheb1_synthesis_matrix([TF=Float64], n::Integer) where {TF<:AbstractFloat}\n\nConstruct the synthesis matrix S that transforms Chebyshev coefficients to function values at Chebyshev points of the 1st kind.\n\nArguments\n\nTF: Element type (defaults to Float64)\nn: Number of points/coefficients\n\n\n\n\n\n","category":"method"},{"location":"cheb/#Einstein.ChebyshevSuite.cheb2_analysis_matrix-Union{Tuple{TF}, Tuple{Type{TF}, Integer}} where TF<:AbstractFloat","page":"Chebyshev Suite","title":"Einstein.ChebyshevSuite.cheb2_analysis_matrix","text":"cheb2_analysis_matrix([TF=Float64], n::Integer) where {TF<:AbstractFloat}\n\nConstruct the analysis matrix A that transforms function values at Chebyshev points of the 2nd kind to Chebyshev coefficients.\n\nArguments\n\nTF: Element type (defaults to Float64)\nn: Number of points/coefficients\n\n\n\n\n\n","category":"method"},{"location":"cheb/#Einstein.ChebyshevSuite.cheb2_angles-Union{Tuple{TF}, Tuple{Type{TF}, Integer}} where TF<:AbstractFloat","page":"Chebyshev Suite","title":"Einstein.ChebyshevSuite.cheb2_angles","text":"cheb1_angles(TF, n) where {TF<:AbstractFloat}\n\nCompute angles for Chebyshev points of the 2nd kind:\n\ntheta_k = frackpin-1 quad k = n-1ldots0\n\nArguments\n\nTF: Type parameter for the angles (e.g., Float64)\nn: Number of points\n\n\n\n\n\n","category":"method"},{"location":"cheb/#Einstein.ChebyshevSuite.cheb2_barycentric_weights-Union{Tuple{TF}, Tuple{Type{TF}, Integer}} where TF<:AbstractFloat","page":"Chebyshev Suite","title":"Einstein.ChebyshevSuite.cheb2_barycentric_weights","text":"cheb2_barycentric_weights([TF=Float64], n::Integer) where {TF<:AbstractFloat}\n\nCompute the barycentric weights for Chebyshev points of the 2nd kind.\n\nArguments\n\nTF: Type parameter for the weights (e.g., Float64)\nn: Number of points\n\nReferences\n\nchebfun/@chebtech2/barywts.m at master · chebfun/chebfun\n\nSee also: BarycentricInterpolation, cheb2_points\n\n\n\n\n\n","category":"method"},{"location":"cheb/#Einstein.ChebyshevSuite.cheb2_differentiation_matrix-Union{Tuple{TR}, Tuple{Type{TR}, Integer}, Tuple{Type{TR}, Integer, Integer}} where TR<:AbstractFloat","page":"Chebyshev Suite","title":"Einstein.ChebyshevSuite.cheb2_differentiation_matrix","text":"cheb2_differentiation_matrix([TR=Float64], n::Integer, k::Integer=1) where {TR<:AbstractFloat}\n\nConstruct a Chebyshev differentiation that maps function values at n Chebyshev points of the 2nd kind  to values of the k-th derivative of the interpolating polynomial at those points.\n\nArguments\n\nTR: Element type (defaults to Float64)\nn::Integer: Number of Chebyshev points\nk::Integer=1: Order of the derivative (default: 1)\n\nReferences\n\nchebfun/@chebcolloc2/chebcolloc2.m at master · chebfun/chebfun\n\n\n\n\n\n","category":"method"},{"location":"cheb/#Einstein.ChebyshevSuite.cheb2_integration_matrix-Union{Tuple{TF}, Tuple{Type{TF}, Integer}} where TF<:AbstractFloat","page":"Chebyshev Suite","title":"Einstein.ChebyshevSuite.cheb2_integration_matrix","text":"cheb2_integration_matrix([TF=Float64], n::Integer) where {TF<:AbstractFloat}\ncheb2_integration_matrix([TF=Float64], n::Integer, x_min::TF, x_max::TF) where {TF<:AbstractFloat}\n\nCompute Chebyshev integration matrix that maps function values at n Chebyshev points of the 2st kind to values of the integral of the interpolating polynomial at those points, with the convention that the first value is zero.\n\nReferences\n\nchebfun/@chebcolloc2/chebcolloc2.m at master · chebfun/chebfun\n\n\n\n\n\n","category":"method"},{"location":"cheb/#Einstein.ChebyshevSuite.cheb2_points-Union{Tuple{TF}, Tuple{Type{TF}, Integer}} where TF<:AbstractFloat","page":"Chebyshev Suite","title":"Einstein.ChebyshevSuite.cheb2_points","text":"cheb2_points([TF=Float64], n::Integer) where {TF<:AbstractFloat}\ncheb2_points([TF=Float64], n::Integer, x_min::TF, x_max::TF) where {TF<:AbstractFloat}\n\nGenerate Chebyshev points of the 1st kind.\n\nFor the standard interval [-1,1]:\n\nx_k = -cosleft(frackpin-1right) quad k = 01ldotsn-1\n\nFor mapped interval [xmin,xmax]:\n\nx_mathrmmapped = fracx_mathrmmax + x_mathrmmin2 + fracx_mathrmmin - x_mathrmmax2x_k\n\nArguments\n\nTF: Type parameter for the grid points (e.g., Float64)\nn: Number of points\nx_min: (Optional) Lower bound of the mapped interval\nx_max: (Optional) Upper bound of the mapped interval\n\nReferences\n\nchebfun/@chebtech2/chebpts.m at master · chebfun/chebfun\n\n\n\n\n\n","category":"method"},{"location":"cheb/#Einstein.ChebyshevSuite.cheb2_quadrature_weights-Union{Tuple{TF}, Tuple{Type{TF}, Integer}} where TF<:AbstractFloat","page":"Chebyshev Suite","title":"Einstein.ChebyshevSuite.cheb2_quadrature_weights","text":"cheb2_quadrature_weights([TF=Float64], n::Integer) where {TF<:AbstractFloat}\n\nCompute quadrature weights for Chebyshev points of the 2nd kind.\n\nArguments\n\nTF: Type parameter for the weights (e.g., Float64)\nn: Number of points\n\nReferences\n\nchebfun/@chebtech2/quadwts.m at master · chebfun/chebfun\n\n\n\n\n\n","category":"method"},{"location":"cheb/#Einstein.ChebyshevSuite.cheb2_synthesis_matrix-Union{Tuple{TF}, Tuple{Type{TF}, Integer}} where TF<:AbstractFloat","page":"Chebyshev Suite","title":"Einstein.ChebyshevSuite.cheb2_synthesis_matrix","text":"cheb2_synthesis_matrix([TF=Float64], n::Integer) where {TF<:AbstractFloat}\n\nConstruct the synthesis matrix S that transforms Chebyshev coefficients to function values at Chebyshev points of the 2nd kind.\n\nArguments\n\nTF: Element type (defaults to Float64)\nn: Number of points/coefficients\n\n\n\n\n\n","category":"method"},{"location":"cheb/#Einstein.ChebyshevSuite.cheb_angles-Union{Tuple{ChebyshevGrid{TF, TNode}}, Tuple{TNode}, Tuple{TF}} where {TF<:AbstractFloat, TNode<:Einstein.ChebyshevSuite.AbstractChebyshevNode}","page":"Chebyshev Suite","title":"Einstein.ChebyshevSuite.cheb_angles","text":"cheb_angles(grid::ChebyshevGrid{TF,TNode}) where {TF<:AbstractFloat,TNode<:AbstractChebyshevNode}\n\nCompute angles for Chebyshev grid of given type.\n\n\n\n\n\n","category":"method"},{"location":"cheb/#Einstein.ChebyshevSuite.cheb_clenshaw-Union{Tuple{TFC}, Tuple{TF}, Tuple{AbstractVector{TFC}, TF}} where {TF<:AbstractFloat, TFC<:Union{Complex{TF}, TF}}","page":"Chebyshev Suite","title":"Einstein.ChebyshevSuite.cheb_clenshaw","text":"cheb_clenshaw(coeffs::AbstractVector{TFC}, x::TFC) where {TF<:AbstractFloat,TFC<:Union{TF,Complex{TF}}\n\nEvaluate Chebyshev coefficients at a point using Clenshaw's algorithm.\n\nArguments\n\ncoeffs: Vector of Chebyshev coefficients c_0 c_1 ldots c_n\nx: Evaluation point in [-1,1]\n\nReferences\n\nchebfun/@chebtech/clenshaw.m at master · chebfun/chebfun\n\n\n\n\n\n","category":"method"},{"location":"cheb/#Einstein.ChebyshevSuite.cheb_coeffs_eval-Union{Tuple{TFC}, Tuple{TF}, Tuple{AbstractVector{TFC}, TF}} where {TF<:AbstractFloat, TFC<:Union{Complex{TF}, TF}}","page":"Chebyshev Suite","title":"Einstein.ChebyshevSuite.cheb_coeffs_eval","text":"cheb_coeffs_eval(coeffs::AbstractVector{TFC}, x::TF) where {TF<:AbstractFloat,TFC<:Union{TF,Complex{TF}}\n\nEvaluate Chebyshev coefficients at a point.\n\nPerformance Notes\n\nClenshaw's algorithm: O(n) operations per point\n(TODO) NDCT: O(n log n) operations for many points simultaneously\n\nReferences\n\nchebfun/@chebtech/feval.m at master · chebfun/chebfun\n\n\n\n\n\n","category":"method"},{"location":"cheb/#Einstein.ChebyshevSuite.cheb_coeffs_integration_matrix-Union{Tuple{TR}, Tuple{Type{TR}, Integer}} where TR<:AbstractFloat","page":"Chebyshev Suite","title":"Einstein.ChebyshevSuite.cheb_coeffs_integration_matrix","text":"cheb_coeffs_integration_matrix([TR=Float64], n::Integer) where {TR<:AbstractFloat}\ncheb_coeffs_integration_matrix([TR=Float64], n::Integer, x_min::TR, x_max::TR) where {TR<:AbstractFloat}\n\nGenerate the Chebyshev coefficient integration matrix that maps Chebyshev coefficients to the coefficients of the integral of the interpolating polynomial.\n\nArguments\n\nTR: Type parameter for the matrix elements (e.g., Float64)\nn: Size of the matrix (n×n)\nx_min: (Optional) Lower bound of the integration interval\nx_max: (Optional) Upper bound of the integration interval\n\nReferences\n\nchebfun/@chebcolloc1/chebcolloc1.m at master · chebfun/chebfun\nchebfun/@chebcolloc2/chebcolloc2.m at master · chebfun/chebfun\n\n\n\n\n\n","category":"method"},{"location":"cheb/#Einstein.ChebyshevSuite.cheb_diff!-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T<:AbstractFloat","page":"Chebyshev Suite","title":"Einstein.ChebyshevSuite.cheb_diff!","text":"cheb_diff(coeffs::AbstractVector{T}) where {T<:AbstractFloat}\ncheb_diff!(coeffs::AbstractVector{T}, coeffs_der::AbstractVector{T}) where {T<:AbstractFloat}\n\nCompute derivatives of Chebyshev coefficients.\n\nArguments\n\ncoeffs: Input vector of Chebyshev coefficients with length n\ncoeffs_der: Pre-allocated output vector for derivative coefficients (length at least n - 1)\n\n\n\n\n\n","category":"method"},{"location":"cheb/#Einstein.ChebyshevSuite.cheb_differentiation_matrix-Union{Tuple{ChebyshevGrid{TF, TNode}}, Tuple{TNode}, Tuple{TF}, Tuple{ChebyshevGrid{TF, TNode}, Integer}} where {TF<:AbstractFloat, TNode<:Einstein.ChebyshevSuite.AbstractChebyshevNode}","page":"Chebyshev Suite","title":"Einstein.ChebyshevSuite.cheb_differentiation_matrix","text":"cheb_differentiation_matrix(grid::ChebyshevGrid{TF,TNode}) where {TF<:AbstractFloat,TNode<:AbstractChebyshevNode}\n\nCompute the Chebyshev differentiation matrix that maps function values at n Chebyshev points to values of the derivative of the interpolating polynomial at those points.\n\n\n\n\n\n","category":"method"},{"location":"cheb/#Einstein.ChebyshevSuite.cheb_dissipation_matrix-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractMatrix{T}, AbstractMatrix{T}}} where T<:AbstractFloat","page":"Chebyshev Suite","title":"Einstein.ChebyshevSuite.cheb_dissipation_matrix","text":"cheb_dissipation_matrix(wts::AbstractVector{T}, S::AbstractMatrix{T}, A::AbstractMatrix{T}; negsum::Bool=true) where T<:AbstractFloat\n\nConstruct a dissipation matrix using precomputed weights and operators, optionally applying the 'negative sum trick', which seems make the simulation more stable according to my tests.\n\nArguments\n\nwts: Vector of dissipation weights\nS: First operator matrix\nA: Second operator matrix\nnegsum: Boolean flag for negative sum trick (default: true)\n\nThe function applies the weights through diagonal scaling and implements the negative sum trick for diagonal elements when negsum is true.\n\n\n\n\n\n","category":"method"},{"location":"cheb/#Einstein.ChebyshevSuite.cheb_dissipation_weights-Union{Tuple{T}, Tuple{Type{T}, Integer, Integer, Integer}} where T<:AbstractFloat","page":"Chebyshev Suite","title":"Einstein.ChebyshevSuite.cheb_dissipation_weights","text":"cheb_dissipation_weights([T=Float64], n::Integer, a::Integer, p::Integer) where {T<:AbstractFloat}\n\nCompute exponential dissipation weights for Chebyshev spectral methods [SLS09].\n\nw_k = e^-alphaleft(k  nright)^2 p quad k = 0 ldots n-1\n\nArguments\n\nT: Type parameter for floating-point precision\nn: Number of grid points\nα: Dissipation strength parameter\np: Order of dissipation\n\nSuggested values\n\nalpha = 36\nand p = 32 for weak dissipation [SLS09, HWB16]\nalpha = 40\nand p = 8 for strong dissipation [Rip23]\n\n\n\n\n\n","category":"method"},{"location":"cheb/#Einstein.ChebyshevSuite.cheb_integration_matrix-Union{Tuple{ChebyshevGrid{TF, TNode}}, Tuple{TNode}, Tuple{TF}} where {TF<:AbstractFloat, TNode<:Einstein.ChebyshevSuite.AbstractChebyshevNode}","page":"Chebyshev Suite","title":"Einstein.ChebyshevSuite.cheb_integration_matrix","text":"cheb_integration_matrix(grid::ChebyshevGrid{TF,TNode}) where {TF<:AbstractFloat,TNode<:AbstractChebyshevNode}\n\nCompute the Chebyshev integration matrix that maps function values at n Chebyshev points to values of the integral of the interpolating polynomial at those points, with the convention that the first value is zero.\n\n\n\n\n\n","category":"method"},{"location":"cheb/#Einstein.ChebyshevSuite.cheb_rectdiff1-Union{Tuple{TR}, Tuple{Type{TR}, Integer, Integer}} where TR<:AbstractFloat","page":"Chebyshev Suite","title":"Einstein.ChebyshevSuite.cheb_rectdiff1","text":"cheb_rectdiff1([TR=Float64], m::Integer, n::Integer) where {TR<:AbstractFloat}\ncheb_rectdiff1([TR=Float64], m::Integer, n::Integer, x_min::TR, x_max::TR) where {TR<:AbstractFloat}\n\nConstructing a 1st-order rectangular differentiation matrix mapping from a 1st-kind grid\n\nArguments:\n\nm : Size of the output grid (number of rows).\nn : Size of the input grid (number of columns).\n\nReferences\n\nchebfun/diffmat.m at master · chebfun/chebfun\n\n\n\n\n\n","category":"method"},{"location":"cheb/#Einstein.ChebyshevSuite.cheb_rectdiff2-Union{Tuple{TR}, Tuple{Type{TR}, Integer, Integer}} where TR<:AbstractFloat","page":"Chebyshev Suite","title":"Einstein.ChebyshevSuite.cheb_rectdiff2","text":"cheb_rectdiff2([TR=Float64], m::Integer, n::Integer) where {TR<:AbstractFloat}\ncheb_rectdiff2([TR=Float64], m::Integer, n::Integer, x_min::TR, x_max::TR) where {TR<:AbstractFloat}\n\nConstruct a 1st-order rectangular differentiation matrix mapping from a 2nd-kind grid.\n\nArguments:\n\nm : Size of the output grid (number of rows)\nn : Size of the input grid (number of columns)\n\nReferences\n\nchebfun/diffmat.m at master · chebfun/chebfun\n\n\n\n\n\n","category":"method"},{"location":"cheb/#Einstein.ChebyshevSuite.cheb_rectdiff_rec-Union{Tuple{TR}, Tuple{Type{TR}, Vararg{Integer, 4}}} where TR<:AbstractFloat","page":"Chebyshev Suite","title":"Einstein.ChebyshevSuite.cheb_rectdiff_rec","text":"cheb_rectdiff([TR=Float64], m::Integer, n::Integer, p::Integer, kind::Integer) where {TR<:AbstractFloat}\n\nConstruct a p-th order rectangular differentiation matrix mapping between Chebyshev grids.\n\nArguments\n\nm : Size of the output grid (number of rows)\nn : Size of the input grid (number of columns)\np : Order of differentiation\nkind : Kind of Chebyshev grid (1 or 2)\n\n\n\n\n\n","category":"method"},{"location":"cheb/#Einstein.ChebyshevSuite.cheb_rectint-Union{Tuple{TR}, Tuple{Type{TR}, Integer, Integer}} where TR<:AbstractFloat","page":"Chebyshev Suite","title":"Einstein.ChebyshevSuite.cheb_rectint","text":"cheb_rectint([TR=Float64], n::Integer) where {TR<:AbstractFloat}\ncheb_rectint([TR=Float64], n::Integer, x_min::TR, x_max::TR) where {TR<:AbstractFloat}\n\nGenerate the Chebyshev integration matrix that operates directly on function values.\n\nArguments\n\nTR: Type parameter for the matrix elements (e.g., Float64)\nn: Size of the matrix (n×n)\nx_min: (Optional) Lower bound of the integration interval\nx_max: (Optional) Upper bound of the integration interval\n\nReferences\n\nchebfun/intmat.m at master · chebfun/chebfun\n\n\n\n\n\n","category":"method"},{"location":"cheb/#Einstein.ChebyshevSuite.ultra_convertmat-Union{Tuple{T}, Tuple{Type{T}, Integer, Integer, Integer}} where T<:AbstractFloat","page":"Chebyshev Suite","title":"Einstein.ChebyshevSuite.ultra_convertmat","text":"ultra_convertmat([T=Float64], K1::Integer, K2::Integer, n::Integer) where {T<:AbstractFloat}\n\nConversion matrix used in the ultraspherical spectral method. Returns N-by-N matrix realization of conversion operator between ultraspherical polynomial bases. Maps N coefficients from C^{(K1)} basis to C^{(K2)} basis.\n\nReferences\n\nchebfun/@ultraS/convertmat.m at master · chebfun/chebfun\n\n\n\n\n\n","category":"method"},{"location":"cheb/#Einstein.ChebyshevSuite.ultra_diffmat-Union{Tuple{TI}, Tuple{TR}, Tuple{Type{TR}, TI, TI}} where {TR<:AbstractFloat, TI<:Integer}","page":"Chebyshev Suite","title":"Einstein.ChebyshevSuite.ultra_diffmat","text":"ultra_diffmat([TR=Float64], m::Integer, n::Integer) where TR<:AbstractFloat\n\nDifferentiation matrices for ultraspherical spectral method that takes n Chebyshev coefficients and returns n C^(m) coefficients that represent the derivative of the Chebyshev series. Here, C^(k) is the ultraspherical polynomial basis with parameter k.\n\nArguments\n\nm::Integer: Order of differentiation\nn::Integer: Number of points\n\nReferences\n\nchebfun/@ultraS/diffmat.m at master · chebfun/chebfun\n\n\n\n\n\n","category":"method"},{"location":"cheb/#Einstein.ChebyshevSuite.ultra_multmat!-Union{Tuple{TFC}, Tuple{AbstractVector{TFC}, Integer}} where TFC<:Union{AbstractFloat, Complex{<:AbstractFloat}}","page":"Chebyshev Suite","title":"Einstein.ChebyshevSuite.ultra_multmat!","text":"ultra_multmat(coeffs::AbstractVector{TFC}, λ::Integer) where {TFC<:Union{AbstractFloat,Complex{<:AbstractFloat}}\nultra_multmat!(coeffs::AbstractVector{TFC}, λ::Integer) where {TFC<:Union{AbstractFloat,Complex{<:AbstractFloat}}\n\nConstruct nxn multiplication matrix representing the multiplication of F in the C^(lambda) basis. ultra_multmat! will overwrite the input vector coeffs.\n\nArguments\n\ncoeffs::AbstractVector{TFC} : Vector of Chebyshev coefficients\nλ::Integer : Order of the ultraspherical basis\n\nReferences\n\nchebfun/@ultraS/multmat.m at master · chebfun/chebfun\n\n\n\n\n\n","category":"method"},{"location":"cheb/#Einstein.ChebyshevSuite.ultra_spconvert-Union{Tuple{T}, Tuple{Type{T}, Integer, Integer}} where T<:AbstractFloat","page":"Chebyshev Suite","title":"Einstein.ChebyshevSuite.ultra_spconvert","text":"ultra_spconvert([T=Float64], λ::T, n::Integer) where {T<:AbstractFloat}\n\nCompute sparse representation for conversion operators. Returns the truncation of the operator that transforms C^lambda (Ultraspherical polynomials) to C^lambda + 1. The truncation gives back a matrix of size n x n.\n\nReferences\n\nchebfun/@ultraS/spconvert.m at master · chebfun/chebfun\n\n\n\n\n\n","category":"method"},{"location":"cheb/#Einstein.ChebyshevSuite.ultra_sphankel-Union{Tuple{AbstractVector{TFC}}, Tuple{TFC}} where TFC<:Union{AbstractFloat, Complex{<:AbstractFloat}}","page":"Chebyshev Suite","title":"Einstein.ChebyshevSuite.ultra_sphankel","text":"sphankel(r::AbstractVector{TFC}) where {TFC<:Union{AbstractFloat,Complex{<:AbstractFloat}}\n\nConstruct a sparse Hankel matrix by forming it as an upside-down Toeplitz matrix. This is required by the ultraspherical multiplication operator.\n\nReferences\n\nchebfun/@ultraS/sphankel.m at master · chebfun/chebfun\n\n\n\n\n\n","category":"method"},{"location":"qnm/#QNM-Suite","page":"QNM Suite","title":"QNM Suite","text":"","category":"section"},{"location":"qnm/","page":"QNM Suite","title":"QNM Suite","text":"Modules = [Einstein.QNMSuite]","category":"page"},{"location":"qnm/","page":"QNM Suite","title":"QNM Suite","text":"Modules = [Einstein.QNMSuite]","category":"page"},{"location":"qnm/#Einstein.QNMSuite.contfrac_lentz-Union{Tuple{T}, Tuple{Type{T}, Function, Function, T, Integer, Integer}} where T<:AbstractFloat","page":"QNM Suite","title":"Einstein.QNMSuite.contfrac_lentz","text":"contfrac_lentz([T=Float64], a::Function, b::Function, tol::T, min_iter::Integer, max_iter::Integer) where {T<:AbstractFloat}\n\nCompute the continued fraction\n\nf(x)=b_0+fraca_1b_1+fraca_2b_2+fraca_3b_3+fraca_4b_4+fraca_5b_5+cdots\n\nusing modified Lentz's method. Translated from duetosymmetry/qnm.\n\nArguments\n\na: A function that returns the aᵢ terms.\nb: A function that returns the bᵢ terms.\ntol: The tolerance for convergence.\nmin_iter: The minimum number of iterations to perform.\nmax_iter: The maximum number of iterations to perform.\n\nReturns\n\nfᵢ: The value of the continued fraction.\nerrorᵢ: The estimated error.\ni: The number of iterations performed.\n\nExamples\n\nCompute the square root of two using continued fractions\n\nsqrt2 = 1 + frac12 + frac12 + frac12 + frac12 + cdots approx 1414213562373095\n\na(i) = 1\nb(i) = i == 0 ? 1 : 2\ncontfrac_lentz(Float64, a, b, 10*eps(Float64), 50, 1000)\n\nCompute Golden Ratio\n\nphi = 1 + frac11 + frac11 + frac11 + cdots approx 1618033988749895\n\na(i) = 1\nb(i) = 1\ncontfrac_lentz(Float64, a, b, 10*eps(Float64), 50, 1000)\n\nReferences\n\nqnm/qnm/contfrac.py at master · duetosymmetry/qnm\n[Pre07, Ste19, Len76, TB86, Tem24]\n\n\n\n\n\n","category":"method"},{"location":"qnm/#Einstein.QNMSuite.qnm_kerr_cf-Union{Tuple{QNMKerrCFParams{TR}}, Tuple{TR}, Tuple{QNMKerrCFParams{TR}, Union{Nothing, SciMLBase.AbstractNonlinearAlgorithm}}} where TR<:AbstractFloat","page":"QNM Suite","title":"Einstein.QNMSuite.qnm_kerr_cf","text":"qnm_kerr_cf(params::QNMKerrCFParams{TR}; alg=RobustMultiNewton(autodiff=AutoFiniteDiff()), kwargs...)\n\nFind the Kerr QNM using the Leaver's method for the radial equation and the Cook-Zalutskiy approach for the angular sector.\n\nArguments\n\nparams: QNMKerrCFParams object containing the Kerr parameters and initial guess\nalg: Nonlinear algorithm to use for the eigenvalue search (default: RobustMultiNewton with AutoFiniteDiff)\nkwargs: Additional keyword arguments to pass to the nonlinear solver\n\n\n\n\n\n","category":"method"},{"location":"qnm/#Einstein.QNMSuite.qnm_kerr_cheb-Union{Tuple{QNMKerrChebParams{TR}}, Tuple{TR}, Tuple{QNMKerrChebParams{TR}, Union{Nothing, SciMLBase.AbstractNonlinearAlgorithm}}} where TR<:AbstractFloat","page":"QNM Suite","title":"Einstein.QNMSuite.qnm_kerr_cheb","text":"qnm_kerr_cheb(params::QNMKerrChebParams{TR}; alg=RobustMultiNewton(autodiff=AutoFiniteDiff()), kwargs...)\n\nFind the Kerr QNM using the Ultraspherical spectral method for the radial equation and the Cook-Zalutskiy approach for the angular sector.\n\nArguments\n\nparams: QNMKerrChebParams object containing the Kerr parameters and initial guess\nalg: Nonlinear algorithm to use for the eigenvalue search (default: RobustMultiNewton with AutoFiniteDiff)\nkwargs: Additional keyword arguments to pass to the nonlinear solver\n\n\n\n\n\n","category":"method"},{"location":"qnm/#Einstein.QNMSuite.qnm_kerr_cheb_δ!-Union{Tuple{TR}, Tuple{StaticArraysCore.SVector{2, TR}, QNMKerrChebCache{TR}}} where TR<:AbstractFloat","page":"QNM Suite","title":"Einstein.QNMSuite.qnm_kerr_cheb_δ!","text":"qnm_kerr_cheb_δ!(cache, ω, l; l_max=20)\n\nPerform one iteration step in the QNM eigenvalue search.\n\nArguments\n\ncache: Pre-computed QNMKerrChebCache object\nω: Current frequency guess\nl: Angular mode number\nl_max: Maximum l value for angular eigenvalue calculation (default: 20)\n\nReturns\n\nDifference between the seperation constant between the radial and angular equations\n\n\n\n\n\n","category":"method"},{"location":"qnm/#Einstein.QNMSuite.qnm_kerr_di-Union{Tuple{QNMKerrDIParams{TR}}, Tuple{TR}, Tuple{QNMKerrDIParams{TR}, Union{Nothing, SciMLBase.AbstractNonlinearAlgorithm}}} where TR<:AbstractFloat","page":"QNM Suite","title":"Einstein.QNMSuite.qnm_kerr_di","text":"qnm_kerr_di(params::QNMKerrDIParams{TR}, alg::AbstractNonlinearAlgorithm=RobustMultiNewton(autodiff=AutoFiniteDiff()); kwargs...) where {TR<:AbstractFloat}\n\nFind the Kerr QNM using the direct integration method for the radial equation and the Cook-Zalutskiy approach for the angular sector.\n\nArguments\n\nparams: QNMKerrDIParams  object containing the Kerr parameters and initial guess\nalg: Nonlinear algorithm to use for the eigenvalue search (default: RobustMultiNewton with AutoFiniteDiff)\nkwargs: Additional keyword arguments to pass to the nonlinear solver\n\n\n\n\n\n","category":"method"},{"location":"qnm/#Einstein.QNMSuite.qnm_kerr_radial_cf-Union{Tuple{TR}, Tuple{Type{TR}, TR, Integer, Integer, Complex{TR}, Complex{TR}}} where TR<:AbstractFloat","page":"QNM Suite","title":"Einstein.QNMSuite.qnm_kerr_radial_cf","text":"qnm_kerr_radial_cf(\n    ::Type{TR},\n    a::TR,\n    s::Integer,\n    m::Integer,\n    A::Complex{TR},\n    ω::Complex{TR};\n    n_inv::Integer=0,\n    cf_tol::TR=typetol(TR),\n    cf_N_min::Integer=300,\n    cf_N_max::Integer=100000,\n) where {TR<:AbstractFloat}\n\nCalculate the radial function using the Leaver scheme [CZ14].\n\nArguments\n\nTR: Type of the floating-point number.\na::TR: Black hole spin.\ns::Integer: spin weight of the field.\nm::Integer: Azimuthal number.\nA::Complex{TR}: Angular separation constant.\nω::Complex{TR}: QNM frequency.\nn_inv::Integer: Number of inversions.\ncf_tol::TR: Tolerance for convergence.\ncfNmin::Integer: Minimum number of iterations.\ncfNmax::Integer: Maximum number of iterations.\n\nReturns\n\ninv_cf::Complex{TR}: The inverse continued fraction.\nerror::TR: The error.\niter::Integer: The number of iterations.\n\nLeaver scheme\n\nbeginaligned\n D_0=delta=1+s+2 xi \n D_1=4 p-2 alpha+gamma-delta-2 \n D_2=2 alpha-gamma+2 \n D_3=alpha(4 p-delta)-sigma \n D_4=alpha(alpha-gamma+1)\nendaligned\n\nbeginaligned\nalpha_n  equiv n^2+left(D_0+1right) n+D_0 \nbeta_n  equiv-2 n^2+left(D_1+2right) n+D_3 \ngamma_n  equiv n^2+left(D_2-3right) n+D_4-D_2+2\nendaligned\n\nThe general continued fraction:\n\n0=beta_0-fracalpha_0 gamma_1beta_1- fracalpha_1 gamma_2beta_2- fracalpha_2 gamma_3beta_3- ldots\n\nThe truncated version of the continued fraction:\n\noperatornameCf(mathrmN) equiv beta_0-fracalpha_0 gamma_1beta_1- fracalpha_1 gamma_2beta_2- fracalpha_2 gamma_3beta_3- ldots fracalpha_mathrmN-1 gamma_mathrmNbeta_mathrmN+alpha_mathrmN mathrmr_mathrmN\n\nThe nth inversion of this truncated continued fraction:\n\nbeginaligned\noperatornameCf(mathrmn  mathrmN) equiv  beta_n-fracalpha_n-1 gamma_nbeta_n-1- fracalpha_n-2 gamma_n-1beta_n-2- ldots fracalpha_0 gamma_1beta_0 \n -fracalpha_n gamma_n+1beta_n+1- fracalpha_n+1 gamma_n+2beta_n+2- cdots fracalpha_N-1 gamma_Nbeta_N+alpha_N r_N\nendaligned\n\nwith operatornameCf(0  mathrmN) equiv operatornameCf(mathrmN) and 0 leq n  N\n\nReferences\n\nCook and Zalutskiy [CZ14]\nqnm/qnm/radial.py at master · duetosymmetry/qnm\n\n\n\n\n\n","category":"method"},{"location":"qnm/#Einstein.QNMSuite.qnm_kerr_radial_di_horizon_series-Union{Tuple{TR}, Tuple{Integer, TR, TR, Integer, Complex{TR}, Complex{TR}, Integer}} where TR<:AbstractFloat","page":"QNM Suite","title":"Einstein.QNMSuite.qnm_kerr_radial_di_horizon_series","text":"qnm_kerr_radial_di_horizon_series(\n    s::Integer,\n    ρ::TR,\n    a::TR,\n    m::Integer,\n    ω::Complex{TR},\n    Λ::Complex{TR},\n    series_order::Integer,\n) where {TR<:AbstractFloat}\n\nCalculate the series expansion of the radial equation at the horizon.\n\nArguments\n\ns::Integer: spin weight of the field.\nρ::TR: compactified radial coordinate.\na::TR: black hole spin parameter.\nm::Integer: azimuthal mode number.\nω::Complex{TR}: QNM frequency.\nΛ::Complex{TR}: separation constant.\nseries_order::Integer: order of the series expansion.\n\nReturns\n\nR0::Complex{TR}: value of the radial function.\ndR0::Complex{TR}: value of the radial derivative.\n\nReferences\n\nRipley [Rip22]\n\n\n\n\n\n","category":"method"},{"location":"qnm/#Einstein.QNMSuite.qnm_kerr_radial_di_inf_series-Union{Tuple{TR}, Tuple{Integer, TR, TR, Integer, Complex{TR}, Complex{TR}, Integer}} where TR<:AbstractFloat","page":"QNM Suite","title":"Einstein.QNMSuite.qnm_kerr_radial_di_inf_series","text":"qnm_kerr_radial_di_inf_series(\n    s::Integer,\n    ρ::TR,\n    a::TR,\n    m::Integer,\n    ω::Complex{TR},\n    Λ::Complex{TR},\n    series_order::Integer,\n) where {TR<:AbstractFloat}\n\nCalculate the series expansion of the radial equation at the horizon.\n\nArguments\n\ns::Integer: spin weight of the field.\nρ::TR: compactified radial coordinate.\na::TR: black hole spin parameter.\nm::Integer: azimuthal mode number.\nω::Complex{TR}: QNM frequency.\nΛ::Complex{TR}: separation constant.\nseries_order::Integer: order of the series expansion.\n\nReturns\n\nR0::Complex{TR}: value of the radial function.\ndR0::Complex{TR}: value of the radial derivative.\n\nReferences\n\nRipley [Rip22]\n\n\n\n\n\n","category":"method"},{"location":"qnm/#Einstein.QNMSuite.qnm_kerr_radial_di_rhs-Union{Tuple{TR}, Tuple{StaticArraysCore.SArray{Tuple{2}, Complex{TR}, 1, 2}, QNMKerrDICache{TR}, TR}} where TR<:AbstractFloat","page":"QNM Suite","title":"Einstein.QNMSuite.qnm_kerr_radial_di_rhs","text":"qnm_kerr_radial_di_rhs(\n    u::SVector{2,Complex{TR}},\n    cache::QNMKerrDICache{TR},\n    ρ::TR,\n) where {TR<:AbstractFloat}\n\nCalculate the right-hand side of the radial equation in hyperboloidal coordinates.\n\nArguments\n\nu::SVector{2,Complex{TR}}: radial function and its derivative.\ncache::QNMKerrDICache{TR}: cache object.\nρ::TR: compactified radial coordinate.\n\nReferences\n\nRipley [Rip22]\n\n\n\n\n\n","category":"method"},{"location":"qnm/#Einstein.QNMSuite.qnm_kerr_radial_di_δ!-Union{Tuple{QNMKerrDICache{TR}}, Tuple{TR}} where TR<:AbstractFloat","page":"QNM Suite","title":"Einstein.QNMSuite.qnm_kerr_radial_di_δ!","text":"qnm_kerr_radial_di_δ!(\n    x::SVector{2,TR},\n    cache::QNMKerrDICache{TR},\n) where {TR<:AbstractFloat}\n\nIntegrate the radial equation from infinity (ρmin) to the horizon (ρmax) and calculate the difference compared to\n\nseries expansion at the horizon (Natural boundary condition)\n0 (Dirichlet boundary condition)\n\nArguments\n\nx::SVector{2,TR}: real and imaginary parts of the QNM frequency.\ncache::QNMKerrDICache{TR}: cache object.\n\nReturns\n\nδ::SVector{2,TR}: real and imaginary parts of the difference.\n\nReferences\n\nRipley [Rip22]\n\n\n\n\n\n","category":"method"},{"location":"qnm/#Einstein.QNMSuite.qnm_polyeig-Union{Tuple{TFC}, Tuple{Type{TFC}, AbstractVector{<:AbstractMatrix}}} where TFC<:Union{AbstractFloat, Complex{<:AbstractFloat}}","page":"QNM Suite","title":"Einstein.QNMSuite.qnm_polyeig","text":"A, E = qnm_polyeig(TFC, pep::AbstractVector{<:AbstractMatrix}) where TFC <: Union{AbstractFloat, Complex{<:AbstractFloat}}\n\nLinearizes a polynomial eigenvalue problem (PEP) a to the companion form, , as in the paper by Mehrmann and Voss. More precisely, for a k-th degree PEP with n-by-n coefficient matrices, this returns matrices A and E, both kn-by-kn, corresponding to the linearized problem\n\nAx = λEx\n\nReferences\n\nMehrmann and Voss [MV04]\n\n\n\n\n\n","category":"method"},{"location":"qnm/#Einstein.QNMSuite.qnm_schw_cheb-Union{Tuple{TR}, Tuple{Type{TR}, Integer, Integer, Integer, Einstein.QNMSuite.SchwPType.T}} where TR<:AbstractFloat","page":"QNM Suite","title":"Einstein.QNMSuite.qnm_schw_cheb","text":"qnm_schw_cheb(::Type{TR}, s::Integer, ℓ::Integer, n::Integer, potential::SchwPType.T; σ_min::TR=zero(TR), σ_max::TR=one(TR), lo_bc::BCType.T=Natural, hi_bc::BCType.T=Natural)\n\nConstruct a polynomial eigenvalue problem for the Schwarzschild spacetime using the hyperboloidal coordinates and the ultraspherical spectral method. The coordinate transformation from standard Schwarzschild coordinates to hyperboloidal coordinates is given by (we use M = 1 in the code):\n\nbeginalign\nsigma = frac2 Mr \ntau = t + 2 M left( lnsigma + ln(1 - sigma) - frac1sigma right) \nr_* = 2 M left(frac1sigma + ln(1 - sigma) - lnsigma right) \nendalign\n\nArguments\n\ns::Integer: Spin\nℓ::Integer: Angular number\nn::Integer: Number of Chebyshev points\npotential::SchwPType.T: Potential type\nσ_min::TR=zero(TR): Minimum value of the radial coordinate (hyperboloidal slicing)\nσ_max::TR=one(TR): Maximum value of the radial coordinate (hyperboloidal slicing)\nlo_bc::BCType.T=BCType.Natural: Boundary condition at the lower boundary, either Natural or Dirichlet.\nhi_bc::BCType.T=BCType.Natural: Boundary condition at the upper boundary, either Natural or Dirichlet.\n\nReturns\n\nA array of matrices representing the Polynomial eigenvalue problem, which can be solved using qnm_polyeig or solvers from the NonlinearEigenproblems.jl package, such as polyeig.\n\nReferences\n\nJaramillo, Panosso Macedo and Al Sheikh [JPA21] and Panosso Macedo [Pan24]\n\n\n\n\n\n","category":"method"},{"location":"qnm/#Einstein.QNMSuite.qnm_schw_reggepoleexp-Union{Tuple{TR}, Tuple{Type{TR}, Integer, Integer, Integer}} where TR<:AbstractFloat","page":"QNM Suite","title":"Einstein.QNMSuite.qnm_schw_reggepoleexp","text":"qnm_schw_reggepoleexp(::Type{TR}, s::TI, l::TI, n::TI) where {TR<:AbstractFloat,TI<:Integer}\n\nCompute the high ell asymptotic expansion of Schwarzschild QNM frequency, using the method of Dolan and Ottewill [DO09].\n\nThe QNM frequency can be written as an expansion in inverse powers of L=ell+frac12\n\nomega_l n=varpi_-1^(n) L+varpi_0^(n)+varpi_1^(n) L^-1+varpi_2^(n) L^-2+ldots\n\nThe lowest expansion coefficients for arbitrary spin beta=1-s^2 and arbitrary overtone number n are given by\n\nbeginaligned\n sqrt27 varpi_-1^(n)=1 \n sqrt27 varpi_0^(n)=-i N \n sqrt27 varpi_1^(n)=fracbeta3-frac5 N^236-frac115432 \n sqrt27 varpi_2^(n)=-i Nleftfracbeta9+frac235 N^23888-frac141515552right \n sqrt27 varpi_3^(n)=-fracbeta^227+frac204 N^2+2113888 beta+frac854160 N^4-1664760 N^2-77693940310784 \n sqrt27 varpi_4^(n)=i Nleftfracbeta^227+frac1100 N^2-271946656 beta+frac11273136 N^4-52753800 N^2+664805352902376448right\nendaligned\n\nArguments\n\nTR: Type of the floating-point number.\ns: Spin weight of the field of interest.\nl: Multipole number of interest.\nn: Overtone number of interest.\n\nReferences\n\n[DO09]\n\n\n\n\n\n","category":"method"},{"location":"fdm/#Finite-Difference-Suite","page":"Finite Difference Suite","title":"Finite Difference Suite","text":"","category":"section"},{"location":"fdm/","page":"Finite Difference Suite","title":"Finite Difference Suite","text":"Modules = [Einstein.FiniteDifferenceSuite]","category":"page"},{"location":"fdm/","page":"Finite Difference Suite","title":"Finite Difference Suite","text":"Modules = [Einstein.FiniteDifferenceSuite]","category":"page"},{"location":"fdm/#Einstein.FiniteDifferenceSuite.UniformGrid","page":"Finite Difference Suite","title":"Einstein.FiniteDifferenceSuite.UniformGrid","text":"UniformGrid{TF} <: AbstractGrid{TF}\n\nUniform grid with constant spacing.\n\nArguments\n\nlower_bound::TF: Lower bound of the grid\nupper_bound::TF: Upper bound of the grid\ndx::TF: Grid spacing\n\n\n\n\n\n","category":"type"},{"location":"fdm/#Einstein.FiniteDifferenceSuite.fdm_boundnum-Tuple{Integer, Integer}","page":"Finite Difference Suite","title":"Einstein.FiniteDifferenceSuite.fdm_boundnum","text":"fdm_boundnum(der_order::Integer, acc_order::Integer)\n\nCalculate the number of coefficients needed for shifted boundary FDM stencil.\n\nArguments\n\nder_order::Integer: Order of the derivative\nacc_order::Integer: Order of accuracy\n\n\n\n\n\n","category":"method"},{"location":"fdm/#Einstein.FiniteDifferenceSuite.fdm_boundop-Union{Tuple{TR}, Tuple{Integer, Integer, TR}} where TR<:AbstractFloat","page":"Finite Difference Suite","title":"Einstein.FiniteDifferenceSuite.fdm_boundop","text":"fdm_boundop(der_order::Integer, acc_order::Integer, dx::TR) where {TR<:AbstractFloat}\n\nCreate a shifted finite difference operator with specified derivative order and accuracy for boundary.\n\nArguments\n\nder_order::Integer: The order of the derivative to approximate\nacc_order::Integer: The desired order of accuracy (must be even)\ndx::TR: Grid spacing\n\n```\n\n\n\n\n\n","category":"method"},{"location":"fdm/#Einstein.FiniteDifferenceSuite.fdm_boundwts-Union{Tuple{T}, Tuple{Type{T}, Integer, Integer}} where T<:Real","page":"Finite Difference Suite","title":"Einstein.FiniteDifferenceSuite.fdm_boundwts","text":"fdm_boundwts([T=Rational{TI}], der_order::TI, acc_order::TI) where {T<:Real, TI<:Integer}\n\nGenerate finite difference coefficients for shifted boundary conditions.\n\nArguments\n\nder_order::Integer: The order of the derivative to approximate\nacc_order::Integer: The desired order of accuracy\n\nReturns\n\nTuple of left and right shifted boundary finite difference coefficients The coefficients are stored in a matrix with the columns representing the different grid points. The columns are ordered from the leftmost grid point to the rightmost grid point.\n\n\n\n\n\n","category":"method"},{"location":"fdm/#Einstein.FiniteDifferenceSuite.fdm_centralnum-Tuple{Integer, Integer}","page":"Finite Difference Suite","title":"Einstein.FiniteDifferenceSuite.fdm_centralnum","text":"fdm_centralnum(der_order::Integer, acc_order::Integer)\n\nCalculate the number of coefficients needed for central FDM stencil.\n\nArguments\n\nder_order::Integer: Order of the derivative\nacc_order::Integer: Order of accuracy\n\nReferences\n\nFinite difference coefficient - Wikipedia\n\n\n\n\n\n","category":"method"},{"location":"fdm/#Einstein.FiniteDifferenceSuite.fdm_centralop-Union{Tuple{TR}, Tuple{Integer, Integer, TR}} where TR<:AbstractFloat","page":"Finite Difference Suite","title":"Einstein.FiniteDifferenceSuite.fdm_centralop","text":"fdm_centralop(der_order::Integer, acc_order::Integer, dx::TR) where {TR<:AbstractFloat}\n\nCreate a central finite difference operator with specified derivative order and accuracy.\n\nArguments\n\nder_order::Integer: The order of the derivative to approximate\nacc_order::Integer: The desired order of accuracy (must be even)\ndx::TR: Grid spacing\n\n```\n\n\n\n\n\n","category":"method"},{"location":"fdm/#Einstein.FiniteDifferenceSuite.fdm_centralwts-Union{Tuple{T}, Tuple{Type{T}, Integer, Integer}} where T<:Real","page":"Finite Difference Suite","title":"Einstein.FiniteDifferenceSuite.fdm_centralwts","text":"fdm_centralwts([T=Rational{TI}], der_order::TI, acc_order::TI) where {T<:Real, TI<:Integer}\n\nGenerate central finite difference coefficients for a given derivative and accuracy order.\n\nArguments\n\nder_order::Integer: The order of the derivative to approximate\nacc_order::Integer: The desired order of accuracy (must be even)\n\nReturns\n\nVector of rational coefficients for the finite difference stencil\n\n\n\n\n\n","category":"method"},{"location":"fdm/#Einstein.FiniteDifferenceSuite.fdm_diffmat-Union{Tuple{TR}, Tuple{Type{TR}, Integer, Integer, Integer}} where TR<:Real","page":"Finite Difference Suite","title":"Einstein.FiniteDifferenceSuite.fdm_diffmat","text":"fdm_diffmat(::Type{TR}, der_order::Integer, acc_order::Integer, n::Integer, with_bound::Bool=false)\n\nConstruct a finite difference matrix for numerical differentiation.\n\nArguments\n\nTR: Type parameter for the real number type to be used\nder_order: Order of the derivative to approximate\nacc_order: Order of accuracy for the approximation\nn: Number of grid points\nwith_bound: Flag to indicate if the matrix should include shifted boundary finite difference coefficients (default: false)\ntranspose: Flag to indicate if the matrix should be transposed (default: false)\n\nReturns\n\nA banded matrix representing the finite difference operator with the specified derivative and accuracy orders. The matrix can be applied to a vector of function values to compute numerical derivatives.\n\nNotes\n\nUses central difference schemes in the interior points\nEmploys one-sided differences near boundaries\nThe resulting matrix has dimensions n×n where n = round(Int, (xmax - xmin) / dx) + 1\n\n\n\n\n\n","category":"method"},{"location":"fdm/#Einstein.FiniteDifferenceSuite.fdm_dissmat-Union{Tuple{TR}, Tuple{Type{TR}, Integer, Integer}} where TR<:Real","page":"Finite Difference Suite","title":"Einstein.FiniteDifferenceSuite.fdm_dissmat","text":"fdm_dissmat(::Type{TR}, diss_order::Integer, n::Integer; transpose::Bool=false)\n\nCreate a finite difference dissipation matrix with specified dissipation order.\n\nArguments\n\nTR: The element type of the matrix\ndiss_order::Integer: The order of the dissipation operator\nn::Integer: The size of the matrix\ntranspose::Bool=false: Whether to return the transpose of the matrix\n\n\n\n\n\n","category":"method"},{"location":"fdm/#Einstein.FiniteDifferenceSuite.fdm_dissnum-Tuple{Integer}","page":"Finite Difference Suite","title":"Einstein.FiniteDifferenceSuite.fdm_dissnum","text":"fdm_dissnum(diss_order::Integer)\n\nCalculate the number of coefficients needed for Kreiss-Oliger dissipation (interior).\n\n\n\n\n\n","category":"method"},{"location":"fdm/#Einstein.FiniteDifferenceSuite.fdm_dissnum_bound-Tuple{Integer}","page":"Finite Difference Suite","title":"Einstein.FiniteDifferenceSuite.fdm_dissnum_bound","text":"fdm_dissnum_bound(diss_order::Integer)\n\nCalculate the number of coefficients needed for Kreiss-Oliger dissipation (boundary).\n\n\n\n\n\n","category":"method"},{"location":"fdm/#Einstein.FiniteDifferenceSuite.fdm_dissop-Union{Tuple{TR}, Tuple{Integer, TR, TR}} where TR<:AbstractFloat","page":"Finite Difference Suite","title":"Einstein.FiniteDifferenceSuite.fdm_dissop","text":"fdm_dissop(diss_order::Integer, σ::TR, dx::TR) where {TR<:AbstractFloat}\n\nCreate a finite difference dissipation operator with specified order (interior).\n\nArguments\n\ndiss_order::Integer: The order of the dissipation operator\nσ::TR: Dissipation strength\ndx::TR: Grid spacing\n\n\n\n\n\n","category":"method"},{"location":"fdm/#Einstein.FiniteDifferenceSuite.fdm_dissop_bound-Union{Tuple{TR}, Tuple{Integer, TR, TR}} where TR<:AbstractFloat","page":"Finite Difference Suite","title":"Einstein.FiniteDifferenceSuite.fdm_dissop_bound","text":"fdm_dissop_bound(diss_order::Integer, σ::TR, dx::TR) where {TR<:AbstractFloat}\n\nCreate a finite difference dissipation operator with specified order (boundary).\n\nArguments\n\ndiss_order::Integer: The order of the dissipation operator\nσ::TR: Dissipation strength\ndx::TR: Grid spacing\n\n\n\n\n\n","category":"method"},{"location":"fdm/#Einstein.FiniteDifferenceSuite.fdm_dissorder-Tuple{Integer}","page":"Finite Difference Suite","title":"Einstein.FiniteDifferenceSuite.fdm_dissorder","text":"fdm_dissorder(acc_order::Integer)\n\nCalculate the order of dissipation needed for a given finite difference accuracy order [B+08]. For a scheme of accuracy order 2r-2, returns dissipation order 2r.\n\n\n\n\n\n","category":"method"},{"location":"fdm/#Einstein.FiniteDifferenceSuite.fdm_disswts-Union{Tuple{TR}, Tuple{Type{TR}, Integer}} where TR<:Real","page":"Finite Difference Suite","title":"Einstein.FiniteDifferenceSuite.fdm_disswts","text":"fdm_disswts([TR=Rational{Int}], diss_order::Integer)\n\nCalculate the weights for Kreiss-Oliger dissipation of given order [B+08].\n\n\n\n\n\n","category":"method"},{"location":"fdm/#Einstein.FiniteDifferenceSuite.fdm_disswts_bound-Union{Tuple{TR}, Tuple{Type{TR}, Integer}} where TR<:Real","page":"Finite Difference Suite","title":"Einstein.FiniteDifferenceSuite.fdm_disswts_bound","text":"fdm_disswts_bound([TR=Rational{Int}], diss_order::Integer)\n\nCalculate the weights for Kreiss-Oliger dissipation of given order at the boundary [B+08].\n\n\n\n\n\n","category":"method"},{"location":"fdm/#Einstein.FiniteDifferenceSuite.fdm_extrapwts_left-Tuple{Int64}","page":"Finite Difference Suite","title":"Einstein.FiniteDifferenceSuite.fdm_extrapwts_left","text":"fdm_extrapwts_left(extrap_order::Int)\n\nGenerate weights for left-sided extrapolation of order extrap_order.\n\nArguments\n\nextrap_order::Int: Order of extrapolation\n\nReturns\n\nVector of rational coefficients for left-sided extrapolation\n\n\n\n\n\n","category":"method"},{"location":"fdm/#Einstein.FiniteDifferenceSuite.fdm_extrapwts_right-Tuple{Int64}","page":"Finite Difference Suite","title":"Einstein.FiniteDifferenceSuite.fdm_extrapwts_right","text":"fdm_extrapwts_right(extrap_order::Int)\n\nGenerate weights for right-sided extrapolation of order extrap_order.\n\nArguments\n\nextrap_order::Int: Order of extrapolation\n\nReturns\n\nVector of rational coefficients for right-sided extrapolation\n\n\n\n\n\n","category":"method"},{"location":"fdm/#Einstein.FiniteDifferenceSuite.fdm_fornbergwts-Union{Tuple{T}, Tuple{Integer, T, AbstractVector{T}}} where T<:Real","page":"Finite Difference Suite","title":"Einstein.FiniteDifferenceSuite.fdm_fornbergwts","text":"fdm_fornbergwts([T=Float64], order::Integer, x0::Real, x::AbstractVector; \n                         hermite::Bool=false)\n\nCalculate finite difference weights for arbitrary-order derivatives using the Fornberg algorithm. Taken from SciML/MethodOfLines.jl.\n\nArguments\n\nT: Type parameter for the weights (defaults to type of x0)\norder: Order of the derivative to approximate\nx0: Point at which to approximate the derivative\nx: Grid points to use in the approximation\nhermite: Whether to include first derivative values (Hermite finite differences)\n\nReturns\n\nIf hermite == false:\n\nVector{T}: Weights for standard finite differences\n\nIf hermite == true:\n\nTuple{Vector{T}, Vector{T}}: Weights for Hermite finite differences\n\nRequirements\n\nFor standard finite differences: N > order\nFor Hermite finite differences: N > order/2 + 1\n\nwhere N is the length of x\n\nExamples\n\n# Standard central difference for first derivative\nx = [-1.0, 0.0, 1.0]\nw = fdm_fornbergwts(1, 0.0, x)\n# Returns approximately [-0.5, 0.0, 0.5]\n\n# Forward difference for second derivative\nx = [0.0, 1.0, 2.0, 3.0]\nw = fdm_fornbergwts(2, 0.0, x)\n\n# Hermite finite difference for third derivative\nx = [-1.0, 0.0, 1.0]\nw_f, w_d = fdm_fornbergwts(3, 0.0, x, hermite=true)\n\nReferences\n\nMethodOfLines.jl/src/discretization/schemes/fornbergcalculateweights.jl at master · SciML/MethodOfLines.jl\nFornberg [For88]\nFornberg [For21]\nFornberg [For98]\nprecision - Numerical derivative and finite difference coefficients: any update of the Fornberg method? - Computational Science Stack Exchange\n\n\n\n\n\n","category":"method"},{"location":"fdm/#Einstein.FiniteDifferenceSuite.fdm_hermitenum-Tuple{Integer, Integer}","page":"Finite Difference Suite","title":"Einstein.FiniteDifferenceSuite.fdm_hermitenum","text":"fdm_hermitenum(der_order::Integer, acc_order::Integer)\n\nCalculate the number of coefficients needed for Hermite FDM stencil.\n\nArguments\n\nder_order::Integer: Order of the derivative\nacc_order::Integer: Order of accuracy\n\nReferences\n\nFornberg [For21]\n\n\n\n\n\n","category":"method"},{"location":"fdm/#Einstein.FiniteDifferenceSuite.fdm_hermiteop-Union{Tuple{TR}, Tuple{Integer, Integer, TR}} where TR<:AbstractFloat","page":"Finite Difference Suite","title":"Einstein.FiniteDifferenceSuite.fdm_hermiteop","text":"fdm_hermiteop(der_order::Integer, acc_order::Integer, dx::TR) where {TR<:AbstractFloat}\n\nCreate a Hermite finite difference operator with specified derivative order and accuracy.\n\nArguments\n\nder_order::Integer: The order of the derivative to approximate\nacc_order::Integer: The desired order of accuracy (must be even)\ndx::TR: Grid spacing\n\n\n\n\n\n","category":"method"},{"location":"fdm/#Einstein.FiniteDifferenceSuite.fdm_hermitewts-Union{Tuple{T}, Tuple{Type{T}, Integer, Integer}} where T<:Real","page":"Finite Difference Suite","title":"Einstein.FiniteDifferenceSuite.fdm_hermitewts","text":"fdm_hermitewts([T=Rational{TI}], der_order::TI, acc_order::TI) where {T<:Real, TI<:Integer}\n\nGenerate Hermite-type finite difference coefficients that include function value and derivative information.\n\nArguments\n\nder_order::Integer: The order of the derivative to approximate (must be ≥ 2)\nacc_order::Integer: The desired order of accuracy\nFor derorder 2,3,6,7,10,11...: accorder must be 4,8,12...\nFor derorder 4,5,8,9,12...: accorder must be 2,6,10...\n\nReturns\n\nVector of rational coefficients for the Hermite-type finite difference stencil\n\n\n\n\n\n","category":"method"},{"location":"fdm/#Einstein.FiniteDifferenceSuite.fdm_integrate_simpson-Union{Tuple{T}, Tuple{AbstractVector{T}, T}} where T<:AbstractFloat","page":"Finite Difference Suite","title":"Einstein.FiniteDifferenceSuite.fdm_integrate_simpson","text":"fdm_integrate_simpson(f::AbstractVector{T}, dx::T) where {T<:AbstractFloat}\n\nIntegrate a function f using Simpson's rule, given the grid spacing dx.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Einstein","category":"page"},{"location":"#Einstein","page":"Home","title":"Einstein","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for Einstein.","category":"page"},{"location":"","page":"Home","title":"Home","text":"warning: Warning\nI'm still actively developing it and migrating code from private repositories to this one, so it may currently lack some features.","category":"page"},{"location":"#Motivation-and-Purpose","page":"Home","title":"Motivation and Purpose","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"After developing hundreds of PDE solvers for various projects, I decided to create Einstein.jl because I couldn't find a library that was both highly convenient and effective for solving partial differential equations (PDEs) in the context of general relativity (GR).","category":"page"},{"location":"","page":"Home","title":"Home","text":"When solving GR PDEs in spherical symmetry or even axisymmetry, the requirements are often far more demanding than in 3+1 cases. These include the need for very long-time simulations, conservation of quantities, highly accurate late-time behavior, and precise computation of quasinormal modes. While I have addressed these challenges individually in the past, I grew tired of copying and pasting solutions from old repositories. Instead, I decided to develop a comprehensive, feature-rich, and highly efficient library. This is my answer to those challenges.","category":"page"},{"location":"#Description","page":"Home","title":"Description","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Einstein.jl is a high-performance suite designed to compute arbitrary-precision solutions of PDEs in GR. It is planned to support solving the following built-in equations (some of which were developed for previous projects and will be ported to this library):","category":"page"},{"location":"","page":"Home","title":"Home","text":"Spatial Discretization\n[x] Chebyshev collocation at Chebyshev points of the first and second kinds (Most of algorithms are translated from Chebfun)\n[x] Finite difference method\n[x] Hermite finite difference method\n[x] Rectangular collocation method (Most of algorithms are translated from Chebfun)\n[x] Ultraspherical spectral method (Most of algorithms are translated from Chebfun)\nFor boundary value problems, I recommend using ApproxFun.jl.\n[ ] Ultraspherical rectangular collocation\nGeneral Utilities\n[x] Correctly rounded floating-point dot/sum using xsum or Kahan summation\n[x] Spin-weighted spheroidal harmonics using the Cook-Zalutskiy spectral method\nQuasinormal Modes\n[ ] Compute quasinormal modes for the Schwarzschild black hole using the Regge-Wheeler-Zerilli equation.\n[ ] Continued fraction method to determine the eigenvalue\n[x] Ultraspherical spectral method in hyperboloidal coordinates to determine the eigenfunction.\n[x] Dolan and Ottewill Regge poles expansion method\n[ ] WKB approximation\n[ ] Direct integration method\n[x] Compute quasinormal modes for the Kerr black hole using the Teukolsky equation.\n[x] Continued fraction method for the radial equation (translated from duetosymmetry/qnm)\n[x] Cook-Zalutskiy spectral method for the angular sector (translated from duetosymmetry/qnm)\n[x] Direct integration method for the radial equation\n[x] Ultraspherical spectral method in hyperboloidal coordinates to determine the eigenfunction.\nUtilities\n[x] Modified Lentz method for continued fractions\n[ ] WKB approximation for general potentials\nTime Domain\nSpherical Symmetry\n[ ] Regge-Wheeler-Zerilli equation\n[ ] Hyperboloidal coordinates\n[ ] Kerr-Schild coordinates\n[ ] Tortoise coordinates\n[ ] Klein-Gordon equation\n[ ] Hyperboloidal coordinates\n[ ] Kerr-Schild coordinates\n[ ] Tortoise coordinates\n[ ] Einstein equations with a scalar field\n[ ] Z4 formulation\n[ ] Hyperboloidal coordinates\nAxisymmetry\n[ ] Teukolsky equation\n[ ] Hyperboloidal coordinates\n[ ] Kerr-Schild coordinates\n[ ] Tortoise coordinates\n[ ] Klein-Gordon equation\n[ ] Hyperboloidal coordinates\n[ ] Kerr-Schild coordinates\n[ ] Tortoise coordinates","category":"page"},{"location":"","page":"Home","title":"Home","text":"While the ChebyshevSuite is inspired by algorithms from Chebfun, it has been significantly enhanced in this package to improve performance and support arbitrary-precision calculations.","category":"page"},{"location":"#Acknowledgments","page":"Home","title":"Acknowledgments","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package is inspired by the following projects, and some of the algorithms are translated / adapted from them:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Chebfun\nJuliaApproximation/ApproxFun.jl\nduetosymmetry/qnm\nSciML/MethodOfLines.jl\nNeal/xsum\nJuliaMath/KahanSummation.jl\ntomtrogdon/URCMethod.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"The author would like to thank the developers of these projects for their contributions to the scientific computing community.","category":"page"},{"location":"#Other-Related-Projects","page":"Home","title":"Other Related Projects","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"lucass-carneiro/QuasinormalModes.jl: A Julia package for computing discrete eigenvalues of second-order ODEs: This package focuses on computing quasinormal modes using the Asymptotic Iteration Method. However, as far as I know, no one has proven that the Asymptotic Iteration Method is guaranteed to converge. So why not use more reliable methods? In any case, it is good to have one more method to compare against.\nJLRipley314/TeukolskyQNMFunctions.jl: Computes quasinormal modes and eigenfunctions of the Teukolsky equation in HPHC coordinates.: Justin Ripley has developed a package that computes the quasinormal modes of the Teukolsky equation based on his own paper. We also follow his paper for the Teukolsky equation in hyperboloidal coordinates.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [Einstein]","category":"page"},{"location":"utils/#General-Utilities","page":"Utilities","title":"General Utilities","text":"","category":"section"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"Modules = [Einstein.Utils]","category":"page"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"Modules = [Einstein.Utils]","category":"page"},{"location":"utils/#Einstein.Utils.BarycentricInterpolation","page":"Utilities","title":"Einstein.Utils.BarycentricInterpolation","text":"BarycentricInterpolation{TF<:AbstractFloat}(points::Vector{TF}, weights::Vector{TF})\n\nA structure representing barycentric interpolation with precomputed weights.\n\nFields\n\npoints::Vector{TF}: Vector of interpolation points (typically Chebyshev points)\nweights::Vector{TF}: Vector of barycentric weights\n\nMethods\n\n(itp::BarycentricInterpolation{TF})(f::AbstractVector{TR}, x0::TF) where {TF<:AbstractFloat,TR<:Union{TF,Complex{TF}}}\n\nEvaluate the interpolant at point x0 for function values f.\n\nReference\n\nchebfun/@chebtech2/bary.m at master · chebfun/chebfun\n\n\n\n\n\n","category":"type"},{"location":"utils/#Einstein.Utils.SWSFun","page":"Utilities","title":"Einstein.Utils.SWSFun","text":"SWSFun{TR<:AbstractFloat}()\n(swsf::SWSFun{TR})(θ::TR)\ncoefficients(swsf::SWSFun)\n\nSpherical-weighted spheroidal harmonics. The eigenvectors contain the C coefficients in the equation:\n\n_s S_ell m(x c)=sum_ell^prime=ell_min ^infty C_ell^prime ell m(c) _s S_ell^prime m(x 0)\n\nwhere C is normalized by\n\nsum_ell^prime=ell_text min ^ell_max leftC_ell^prime ell m(c)right^2=1\n\nand the phase is chosen such that C_ell^prime ell m(c) is real for ell^prime=ell [CZ14]. The spin-weighted spheroidal harmonics are normalized such that\n\nint_0^pi _s S_ell m(x c) _s S^*_ell m(x c) sin(theta) dtheta = 1\n\nArguments\n\ns::Integer: spin\nc::Complex{TR}: oblateness parameter\nm::Integer: azimuthal number\nl::Integer: angular number\nl_max::Integer: maximum angular number\n\n\n\n\n\n","category":"type"},{"location":"utils/#Einstein.Utils.dot_kahan-Union{Tuple{T}, Tuple{StridedVector{T}, StridedVector{T}}} where T<:Number","page":"Utilities","title":"Einstein.Utils.dot_kahan","text":"dot_kahan(v1::StridedVector{T}, v2::StridedVector{T}) where {T<:Number}\n\nCompute the dot product using Kahan summation algorithm to reduce numerical errors.\n\nNote\n\nSlower than dot_xsum for large vectors, but faster for small vectors.\nSimilar performance to dot_kahan_neumaier\nBoth input vectors must have the same length, which is not checked for performance reasons.\n\n\n\n\n\n","category":"method"},{"location":"utils/#Einstein.Utils.dot_kahan_neumaier-Union{Tuple{T}, Tuple{StridedVector{T}, StridedVector{T}}} where T<:Number","page":"Utilities","title":"Einstein.Utils.dot_kahan_neumaier","text":"dot_kahan_neumaier(v1::StridedVector{T}, v2::StridedVector{T}) where {T<:Number}\n\nNeumaier's variant of Kahan summation algorithm to reduce numerical errors.\n\nNote\n\nSlower than dot_xsum for large vectors, but faster for small vectors.\nSimilar performance to dot_kahan\nUses loop unrolling for better performance while maintaining Kahan summation's\n\nnumerical stability. Processes two elements per iteration when possible.\n\nReferences\n\nJuliaMath/KahanSummation.jl\n\n\n\n\n\n","category":"method"},{"location":"utils/#Einstein.Utils.dot_xsum-Tuple{StridedVector{Float64}, StridedVector{Float64}}","page":"Utilities","title":"Einstein.Utils.dot_xsum","text":"dot_xsum(x::StridedVector{T}, y::StridedVector{T}) where {T<:Real}\n\nCompute the dot product of two vectors using extended precision accumulation. Uses the xsum package for improved numerical accuracy.\n\nNote\n\nVery fast for large vectors, but a bit slower than Kahan summation for small vectors.\nBoth input vectors must have the same length, which is not checked for performance reasons.\n\nReferences\n\nNeal [Nea15]\nJuliaMath/Xsum.jl\nRadford Neal / xsum · GitLab\n\n\n\n\n\n","category":"method"},{"location":"utils/#Einstein.Utils.sum_kahan-Union{Tuple{StridedVector{T}}, Tuple{T}} where T<:Number","page":"Utilities","title":"Einstein.Utils.sum_kahan","text":"sum_kahan(v::StridedVector{T}) where {T<:Number}\n\nCompute the sum using Kahan summation algorithm to reduce numerical errors.\n\nNote\n\nSlower than sum_xsum for large vectors, but faster for small vectors.\nSimilar performance to sum_kahan_neumaier\n\n\n\n\n\n","category":"method"},{"location":"utils/#Einstein.Utils.sum_kahan_neumaier-Union{Tuple{StridedVector{T}}, Tuple{T}} where T<:Number","page":"Utilities","title":"Einstein.Utils.sum_kahan_neumaier","text":"sum_kahan_neumaier(v::StridedVector{T}) where {T<:Number}\n\nNeumaier's variant of Kahan summation algorithm to reduce numerical errors.\n\nNote\n\nSlower than sum_xsum for large vectors, but faster for small vectors.\nSimilar performance to sum_kahan\nUses loop unrolling for better performance while maintaining Kahan summation's\n\nnumerical stability. Processes two elements per iteration when possible.\n\nReferences\n\nJuliaMath/KahanSummation.jl\n\n\n\n\n\n","category":"method"},{"location":"utils/#Einstein.Utils.sum_xsum-Tuple{StridedVector{Float64}}","page":"Utilities","title":"Einstein.Utils.sum_xsum","text":"sum_xsum(vec::StridedVector{T}) where {T<:Union{Float32,Float64}}\n\nCompute the sum of a vector using extended precision accumulation. Uses the xsum package for improved numerical accuracy.\n\nNote\n\nVery fast for large vectors, but a bit slower than Kahan summation for small vectors (n ⪅ 80)\n\nReferences\n\nNeal [Nea15]\nJuliaMath/Xsum.jl\nRadford Neal / xsum · GitLab\n\n\n\n\n\n","category":"method"},{"location":"utils/#Einstein.Utils.sws_A0-Tuple{Integer, Integer}","page":"Utilities","title":"Einstein.Utils.sws_A0","text":"sws_A0(s::Integer, l::Integer) where {TR<:AbstractFloat}\n\nCalculate angular separation constant at a = 0.\n\n_s A_ell m(0)=l(l+1)-s(s+1)\n\nArguments\n\ns::Integer: spin\nl::Integer: angular number\n\n\n\n\n\n","category":"method"},{"location":"utils/#Einstein.Utils.sws_eigM-Union{Tuple{TR}, Tuple{Type{TR}, Integer, Complex{TR}, Integer, Integer}} where TR<:AbstractFloat","page":"Utilities","title":"Einstein.Utils.sws_eigM","text":"sws_eigM(::Type{TR}, s::Integer, c::Complex{TR}, m::Integer, l_max::Integer) where {TR<:AbstractFloat}\nsws_eigM!(M::AbstractMatrix{TR}, s::Integer, c::Complex, m::Integer, l_max::Integer) where {TR<:AbstractFloat}\n\nConstruct the spherical-spheroidal decomposition matrix truncated at l_max.\n\nArguments\n\nTR: Type for floating point conversion\ns::Integer: spin\nc::Complex: oblateness parameter\nm::Integer: azimuthal number\nl_max::Integer: maximum angular number\n\nReferences\n\nCook and Zalutskiy [CZ14]\nduetosymmetry/qnm\n\n\n\n\n\n","category":"method"},{"location":"utils/#Einstein.Utils.sws_eigen-Union{Tuple{TR}, Tuple{Type{TR}, Integer, Complex{TR}, Integer, Integer}} where TR<:AbstractFloat","page":"Utilities","title":"Einstein.Utils.sws_eigen","text":"sws_eigen(::Type{TR}, s::Integer, c::Complex{TR}, m::Integer, l_max::Integer) where {TR<:AbstractFloat}\n\nCalculate eigenvalues and eigenvectors of the spherical-spheroidal decomposition matrix.\n\nArguments\n\nTR: Type for floating point conversion\ns::Integer: spin\nc::Complex: oblateness parameter\nm::Integer: azimuthal number\nl_max::Integer: maximum angular number\n\nReferences\n\nCook and Zalutskiy [CZ14]\nduetosymmetry/qnm\n\n\n\n\n\n","category":"method"},{"location":"utils/#Einstein.Utils.sws_l_min-Tuple{Integer, Integer}","page":"Utilities","title":"Einstein.Utils.sws_l_min","text":"sws_l_min(s::Integer, m::Integer)\n\nMinimum allowed value of l for given s, m. Returns max(|s|, |m|).\n\nArguments\n\ns::Integer: spin\nm::Integer: azimuthal number\n\n\n\n\n\n","category":"method"}]
}
